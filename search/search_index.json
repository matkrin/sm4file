{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation of sm4file","text":""},{"location":"#installing","title":"Installing","text":"<p>Installation via pip:</p> <pre><code>pip install sm4file\n</code></pre>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code>from sm4file import Sm4\n\n\nsm4 = Sm4(\"path/to/sm4-file\")\n</code></pre> <p>This return a list of all acquired measurement channels. Metadata can be accessed as properties on a channel. For example to print the bias voltage for all channels:</p> <pre><code>for channel in sm4:\n    print(channel.bias)\n</code></pre> <p>The measurement's numerical data is stored in the <code>data</code> property on each channel. For images this is a two dimensional numpy array. For lines / spectra it is a (n, m) where n is the number of acquired data points and m is the number of spectra + 1. The array's first column contains the x-values and all subsequent ones the corresponding y-values.</p>"},{"location":"api-user/","title":"API Reference","text":""},{"location":"api-user/#sm4file","title":"<code>sm4file</code>","text":""},{"location":"api-user/#sm4file-classes","title":"Classes","text":""},{"location":"api-user/#sm4file.Sm4","title":"<code>Sm4</code>","text":"<p>Main class representing the content of a .sm4 filepath</p> <p>Contains all channels of the file as <code>Sm4Channel</code>s. To access the channels, the instantiated object can be indexed or iterated over, like a list.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>SM4-file to read</p> required"},{"location":"api-user/#sm4file.Sm4-functions","title":"Functions","text":""},{"location":"api-user/#sm4file.Sm4.current_channels","title":"<code>current_channels()</code>","text":"<p>Get only current channels</p>"},{"location":"api-user/#sm4file.Sm4.save_prm","title":"<code>save_prm(out_file)</code>","text":"<p>Save file parameters as text file</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <code>str</code> <p>Name of file that is created</p> required"},{"location":"api-user/#sm4file.Sm4.topography_channels","title":"<code>topography_channels()</code>","text":"<p>Get only topographic channels</p>"},{"location":"api-user/#sm4file.Sm4Channel","title":"<code>Sm4Channel</code>  <code>dataclass</code>","text":"<p>Class holding the information about a channel</p> <p>Attributes:</p> Name Type Description <code>page_type</code> <code>RhkPageType</code> <p>Type of page/channel</p> <code>line_type</code> <code>RhkLineType</code> <p>Type of line</p> <code>datetime</code> <code>datetime</code> <p>Datetime of measurement</p> <code>xres</code> <code>int</code> <p>Resolution in x, e.g. number of pixels for images</p> <code>yres</code> <code>int</code> <p>Resolution in y, e.g. number of pixels for images</p> <code>image_type</code> <code>RhkImageType</code> <p>Type of image</p> <code>scan_type</code> <code>RhkScanType</code> <p>Type of scan</p> <code>scan_direction</code> <code>str</code> <p>Direction of scanning</p> <code>xsize</code> <code>float</code> <p>Physical size of e.g. image in x (in m)</p> <code>ysize</code> <code>float</code> <p>Physical size of e.g. image in y (in m)</p> <code>z_scale</code> <code>float</code> <code>x_offset</code> <code>float</code> <p>Offset in x-direction</p> <code>y_offset</code> <code>float</code> <p>Offset in y-direction</p> <code>z_offset</code> <code>float</code> <code>period</code> <code>float</code> <p>Acquisition time of a single data point (in s)</p> <code>bias</code> <code>float</code> <p>Bias voltage (in V)</p> <code>current</code> <code>float</code> <p>Tunneling current (in A)</p> <code>angle</code> <code>float</code> <p>Scan angle (in deg)</p> <code>data</code> <code>NDArray[float32]</code> <p>Measuremet data</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#plot-images-from-all-channels","title":"Plot images from all channels","text":"<pre><code>from sm4file import Sm4\nimport matplotlib.pyplot as plt\n\n\nsm4 = Sm4(\"path/to/sm4-file\")\n\nfor channel in sm4:\n    plt.imshow(channel.data)\n    plt.title(f\"{channel.label} - {channel.scan_direction}\")\n    plt.show()  # or plt.save()\n</code></pre>"},{"location":"examples/#plot-all-spectra-eg-iv","title":"Plot all spectra, e.g. IV","text":"<pre><code>from sm4file import Sm4\nimport matplotlib.pyplot as plt\n\n\nsm4 = Sm4(\"path/to/sm4-file\")\n\nfor channel in sm4:\n    for i in range(1, len(channel.data[0])):\n        plt.plot(channel.data[:, 0], channel.data[:, i], label=f\"{i}\")\n        plt.title(channel.label)\n        plt.legend()\n\n    plt.show()  # or plt.save()\n</code></pre>"},{"location":"api-dev/cursor/","title":"Cursor","text":""},{"location":"api-dev/cursor/#sm4file.cursor","title":"<code>sm4file.cursor</code>","text":""},{"location":"api-dev/cursor/#sm4file.cursor-classes","title":"Classes","text":""},{"location":"api-dev/cursor/#sm4file.cursor.Cursor","title":"<code>Cursor</code>","text":"<p>Class for handeling a buffer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>class Cursor:\n    \"\"\"Class for handeling a buffer\"\"\"\n\n    def __init__(self, buffer: BufferedReader):\n        self._buffer = buffer\n\n    def set_position(self, position: int) -&gt; None:\n        \"\"\"Set the postition of the cursor\n\n        Args:\n            position: Byte-position to set\n        \"\"\"\n        self._buffer.seek(position)\n\n    def skip(self, bytes_to_skip: int) -&gt; None:\n        \"\"\"Skip bytes of the buffer\n\n        Args:\n            bytes_to_skip: Number of bytes to skip\n        \"\"\"\n        self.set_position(self._buffer.tell() + bytes_to_skip)\n\n    def read(self, num_bytes: int) -&gt; bytes:\n        \"\"\"Read bytes, while moving cursor\n\n        Args:\n            num_bytes: Number of bytes to read\n\n        Returns:\n            bytes: The read bytes\n        \"\"\"\n        return self._buffer.read(num_bytes)\n\n    def read_string(self, str_len: int) -&gt; str:\n        \"\"\"Read bytes as string\n\n        Args:\n            str_len: Length of the string to read\n\n        Returns:\n            The read string\n        \"\"\"\n        return \"\".join(\n            [chr(i).rstrip(\"\\x00\") for i in self._buffer.read(str_len)]\n        )\n\n    def read_sm4_string(self) -&gt; str:\n        \"\"\"Read bytes as a UTF-16 encoded string. In SM4-files string data\n        always contains the length of the string as a u16 number, followed\n        by the string itself\n\n        Returns:\n            The read string\n        \"\"\"\n        length = self.read_u16_le()\n        return self.read_string(length * 2).strip()\n\n    def read_u8_le(self) -&gt; int:\n        \"\"\"Read a 8-bit unsigned integer\n\n        Returns:\n            The read integer\n        \"\"\"\n        return cast(int, struct.unpack(\"&lt;B\", self._buffer.read(1))[0])\n\n    def read_u16_le(self) -&gt; int:\n        \"\"\"Read a 16-bit unsigned integer\n\n        Returns:\n            The read integer\n        \"\"\"\n        return cast(int, struct.unpack(\"&lt;H\", self._buffer.read(2))[0])\n\n    def read_i16_le(self) -&gt; int:\n        \"\"\"Read a 16-bit signed integer\n\n        Returns:\n            The read integer\n        \"\"\"\n        return cast(int, struct.unpack(\"&lt;h\", self._buffer.read(2))[0])\n\n    def read_u32_le(self) -&gt; int:\n        \"\"\"Read a 32-bit unsigned integer\n\n        Returns:\n            The read integer\n        \"\"\"\n        return cast(int, struct.unpack(\"&lt;I\", self._buffer.read(4))[0])\n\n    def read_i32_le(self) -&gt; int:\n        \"\"\"Read a 32-bit signed integer\n\n        Returns:\n            The read integer\n        \"\"\"\n        return cast(int, struct.unpack(\"&lt;i\", self._buffer.read(4))[0])\n\n    def read_u64_le(self) -&gt; int:\n        \"\"\"Read a 64-bit unsigned integer\n\n        Returns:\n            The read integer\n        \"\"\"\n        return cast(int, struct.unpack(\"&lt;q\", self._buffer.read(8))[0])\n\n    def read_f32_le(self) -&gt; float:\n        \"\"\"Read a 64-bit floating point number\n\n        Returns:\n            The read float\n        \"\"\"\n        return cast(float, struct.unpack(\"&lt;f\", self._buffer.read(4))[0])\n\n    def read_f64_le(self) -&gt; float:\n        \"\"\"Read a 64-bit floating point number\n\n        Returns:\n            The read float\n        \"\"\"\n        return cast(float, struct.unpack(\"&lt;d\", self._buffer.read(8))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor-functions","title":"Functions","text":""},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read","title":"<code>read(num_bytes)</code>","text":"<p>Read bytes, while moving cursor</p> <p>Parameters:</p> Name Type Description Default <code>num_bytes</code> <code>int</code> <p>Number of bytes to read</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read(self, num_bytes: int) -&gt; bytes:\n    \"\"\"Read bytes, while moving cursor\n\n    Args:\n        num_bytes: Number of bytes to read\n\n    Returns:\n        bytes: The read bytes\n    \"\"\"\n    return self._buffer.read(num_bytes)\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_f32_le","title":"<code>read_f32_le()</code>","text":"<p>Read a 64-bit floating point number</p> <p>Returns:</p> Type Description <code>float</code> <p>The read float</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_f32_le(self) -&gt; float:\n    \"\"\"Read a 64-bit floating point number\n\n    Returns:\n        The read float\n    \"\"\"\n    return cast(float, struct.unpack(\"&lt;f\", self._buffer.read(4))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_f64_le","title":"<code>read_f64_le()</code>","text":"<p>Read a 64-bit floating point number</p> <p>Returns:</p> Type Description <code>float</code> <p>The read float</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_f64_le(self) -&gt; float:\n    \"\"\"Read a 64-bit floating point number\n\n    Returns:\n        The read float\n    \"\"\"\n    return cast(float, struct.unpack(\"&lt;d\", self._buffer.read(8))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_i16_le","title":"<code>read_i16_le()</code>","text":"<p>Read a 16-bit signed integer</p> <p>Returns:</p> Type Description <code>int</code> <p>The read integer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_i16_le(self) -&gt; int:\n    \"\"\"Read a 16-bit signed integer\n\n    Returns:\n        The read integer\n    \"\"\"\n    return cast(int, struct.unpack(\"&lt;h\", self._buffer.read(2))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_i32_le","title":"<code>read_i32_le()</code>","text":"<p>Read a 32-bit signed integer</p> <p>Returns:</p> Type Description <code>int</code> <p>The read integer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_i32_le(self) -&gt; int:\n    \"\"\"Read a 32-bit signed integer\n\n    Returns:\n        The read integer\n    \"\"\"\n    return cast(int, struct.unpack(\"&lt;i\", self._buffer.read(4))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_sm4_string","title":"<code>read_sm4_string()</code>","text":"<p>Read bytes as a UTF-16 encoded string. In SM4-files string data always contains the length of the string as a u16 number, followed by the string itself</p> <p>Returns:</p> Type Description <code>str</code> <p>The read string</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_sm4_string(self) -&gt; str:\n    \"\"\"Read bytes as a UTF-16 encoded string. In SM4-files string data\n    always contains the length of the string as a u16 number, followed\n    by the string itself\n\n    Returns:\n        The read string\n    \"\"\"\n    length = self.read_u16_le()\n    return self.read_string(length * 2).strip()\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_string","title":"<code>read_string(str_len)</code>","text":"<p>Read bytes as string</p> <p>Parameters:</p> Name Type Description Default <code>str_len</code> <code>int</code> <p>Length of the string to read</p> required <p>Returns:</p> Type Description <code>str</code> <p>The read string</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_string(self, str_len: int) -&gt; str:\n    \"\"\"Read bytes as string\n\n    Args:\n        str_len: Length of the string to read\n\n    Returns:\n        The read string\n    \"\"\"\n    return \"\".join(\n        [chr(i).rstrip(\"\\x00\") for i in self._buffer.read(str_len)]\n    )\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_u16_le","title":"<code>read_u16_le()</code>","text":"<p>Read a 16-bit unsigned integer</p> <p>Returns:</p> Type Description <code>int</code> <p>The read integer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_u16_le(self) -&gt; int:\n    \"\"\"Read a 16-bit unsigned integer\n\n    Returns:\n        The read integer\n    \"\"\"\n    return cast(int, struct.unpack(\"&lt;H\", self._buffer.read(2))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_u32_le","title":"<code>read_u32_le()</code>","text":"<p>Read a 32-bit unsigned integer</p> <p>Returns:</p> Type Description <code>int</code> <p>The read integer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_u32_le(self) -&gt; int:\n    \"\"\"Read a 32-bit unsigned integer\n\n    Returns:\n        The read integer\n    \"\"\"\n    return cast(int, struct.unpack(\"&lt;I\", self._buffer.read(4))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_u64_le","title":"<code>read_u64_le()</code>","text":"<p>Read a 64-bit unsigned integer</p> <p>Returns:</p> Type Description <code>int</code> <p>The read integer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_u64_le(self) -&gt; int:\n    \"\"\"Read a 64-bit unsigned integer\n\n    Returns:\n        The read integer\n    \"\"\"\n    return cast(int, struct.unpack(\"&lt;q\", self._buffer.read(8))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.read_u8_le","title":"<code>read_u8_le()</code>","text":"<p>Read a 8-bit unsigned integer</p> <p>Returns:</p> Type Description <code>int</code> <p>The read integer</p> Source code in <code>sm4file/cursor.py</code> <pre><code>def read_u8_le(self) -&gt; int:\n    \"\"\"Read a 8-bit unsigned integer\n\n    Returns:\n        The read integer\n    \"\"\"\n    return cast(int, struct.unpack(\"&lt;B\", self._buffer.read(1))[0])\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.set_position","title":"<code>set_position(position)</code>","text":"<p>Set the postition of the cursor</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>Byte-position to set</p> required Source code in <code>sm4file/cursor.py</code> <pre><code>def set_position(self, position: int) -&gt; None:\n    \"\"\"Set the postition of the cursor\n\n    Args:\n        position: Byte-position to set\n    \"\"\"\n    self._buffer.seek(position)\n</code></pre>"},{"location":"api-dev/cursor/#sm4file.cursor.Cursor.skip","title":"<code>skip(bytes_to_skip)</code>","text":"<p>Skip bytes of the buffer</p> <p>Parameters:</p> Name Type Description Default <code>bytes_to_skip</code> <code>int</code> <p>Number of bytes to skip</p> required Source code in <code>sm4file/cursor.py</code> <pre><code>def skip(self, bytes_to_skip: int) -&gt; None:\n    \"\"\"Skip bytes of the buffer\n\n    Args:\n        bytes_to_skip: Number of bytes to skip\n    \"\"\"\n    self.set_position(self._buffer.tell() + bytes_to_skip)\n</code></pre>"},{"location":"api-dev/sm4_file_all/","title":"Sm4File","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file","title":"<code>sm4file.sm4_file</code>","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file-attributes","title":"Attributes","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeader","title":"<code>Sm4PageHeader = Union[Sm4PageHeaderSequential, Sm4PageHeaderDefault]</code>  <code>module-attribute</code>","text":"<p>Type for the Page Header</p>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file-classes","title":"Classes","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkImageType","title":"<code>RhkImageType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of Images</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkImageType(Enum):\n    \"\"\"Types of Images\"\"\"\n\n    RHK_IMAGE_NORMAL = 0\n    RHK_IMAGE_AUTOCORRELATED = 1\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkLineType","title":"<code>RhkLineType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of lines</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkLineType(Enum):\n    \"\"\"Types of lines\"\"\"\n\n    RHK_LINE_NOT_A_LINE = 0\n    RHK_LINE_HISTOGRAM = 1\n    RHK_LINE_CROSS_SECTION = 2\n    RHK_LINE_LINE_TEST = 3\n    RHK_LINE_OSCILLOSCOPE = 4\n    RHK_LINE_RESERVED = 5\n    RHK_LINE_NOISE_POWER_SPECTRUM = 6\n    RHK_LINE_IV_SPECTRUM = 7\n    RHK_LINE_IZ_SPECTRUM = 8\n    RHK_LINE_IMAGE_X_AVERAGE = 9\n    RHK_LINE_IMAGE_Y_AVERAGE = 10\n    RHK_LINE_NOISE_AUTOCORRELATION_SPECTRUM = 11\n    RHK_LINE_MULTICHANNEL_ANALYSER_DATA = 12\n    RHK_LINE_RENORMALIZED_IV = 13\n    RHK_LINE_IMAGE_HISTOGRAM_SPECTRA = 14\n    RHK_LINE_IMAGE_CROSS_SECTION = 15\n    RHK_LINE_IMAGE_AVERAGE = 16\n    RHK_LINE_IMAGE_CROSS_SECTION_G = 17\n    RHK_LINE_IMAGE_OUT_SPECTRA = 18\n    RHK_LINE_DATALOG_SPECTRUM = 19\n    RHK_LINE_GXY = 20\n    RHK_LINE_ELECTROCHEMISTRY = 21\n    RHK_LINE_DISCRETE_SPECTROSCOPY = 22\n    RHK_LINE_DATA_LOGGER = 23\n    RHK_LINE_TIME_SPECTROSCOPY = 24\n    RHK_LINE_ZOOM_FFT = 25\n    RHK_LINE_FREQUENCY_SWEEP = 26\n    RHK_LINE_PHASE_ROTATE = 27\n    RHK_LINE_FIBER_SWEEP = 28\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkObjectType","title":"<code>RhkObjectType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of Objects</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkObjectType(Enum):\n    \"\"\"Types of Objects\"\"\"\n\n    RHK_OBJECT_UNDEFINED = 0\n    RHK_OBJECT_PAGE_INDEX_HEADER = 1\n    RHK_OBJECT_PAGE_INDEX_ARRAY = 2\n    RHK_OBJECT_PAGE_HEADER = 3\n    RHK_OBJECT_PAGE_DATA = 4\n    RHK_OBJECT_IMAGE_DRIFT_HEADER = 5\n    RHK_OBJECT_IMAGE_DRIFT = 6\n    RHK_OBJECT_SPEC_DRIFT_HEADER = 7\n    RHK_OBJECT_SPEC_DRIFT_DATA = 8\n    RHK_OBJECT_COLOR_INFO = 9\n    RHK_OBJECT_STRING_DATA = 10\n    RHK_OBJECT_TIP_TRACK_HEADER = 11\n    RHK_OBJECT_TIP_TRACK_DATA = 12\n    RHK_OBJECT_PRM = 13\n    RHK_OBJECT_THUMBNAIL = 14\n    RHK_OBJECT_PRM_HEADER = 15\n    RHK_OBJECT_THUMBNAIL_HEADER = 16\n    RHK_OBJECT_API_INFO = 17\n    RHK_OBJECT_HISTORY_INFO = 18\n    RHK_OBJECT_PIEZO_SENSITIVITY = 19\n    RHK_OBJECT_FREQUENCY_SWEEP_DATA = 20\n    RHK_OBJECT_SCAN_PROCESSOR_INFO = 21\n    RHK_OBJECT_PLL_INFO = 22\n    RHK_OBJECT_CH1_DRIVE_INFO = 23\n    RHK_OBJECT_CH2_DRIVE_INFO = 24\n    RHK_OBJECT_LOCKIN0_INFO = 25\n    RHK_OBJECT_LOCKIN1_INFO = 26\n    RHK_OBJECT_ZPI_INFO = 27\n    RHK_OBJECT_KPI_INFO = 28\n    RHK_OBJECT_AUX_PI_INFO = 29\n    RHK_OBJECT_LOWPASS_FILTER0_INFO = 30\n    RHK_OBJECT_LOWPASS_FILTER1_INFO = 31\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkPageDataType","title":"<code>RhkPageDataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of Page Data</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkPageDataType(Enum):\n    \"\"\"Types of Page Data\"\"\"\n\n    RHK_DATA_IMAGE = 0\n    RHK_DATA_LINE = 1\n    RHK_DATA_XY_DATA = 2\n    RHK_DATA_ANNOTATED_LINE = 3\n    RHK_DATA_TEXT = 4\n    RHK_DATA_ANNOTATED_TEXT = 5\n    RHK_DATA_SEQUENTIAL = 6\n    RHK_DATA_MOVIE = 7\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkPageSourceType","title":"<code>RhkPageSourceType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of Page Source</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkPageSourceType(Enum):\n    \"\"\"Types of Page Source\"\"\"\n\n    RHK_SOURCE_RAW = 0\n    RHK_SOURCE_PROCESSED = 1\n    RHK_SOURCE_CALCULATED = 2\n    RHK_SOURCE_IMPORTED = 3\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkPageType","title":"<code>RhkPageType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of Pages</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkPageType(Enum):\n    \"\"\"Types of Pages\"\"\"\n\n    RHK_PAGE_UNDEFINED = 0\n    RHK_PAGE_TOPOGRAPHIC = 1\n    RHK_PAGE_CURRENT = 2\n    RHK_PAGE_AUX = 3\n    RHK_PAGE_FORCE = 4\n    RHK_PAGE_SIGNAL = 5\n    RHK_PAGE_FFT_TRANSFORM = 6\n    RHK_PAGE_NOISE_POWER_SPECTRUM = 7\n    RHK_PAGE_LINE_TEST = 8\n    RHK_PAGE_OSCILLOSCOPE = 9\n    RHK_PAGE_IV_SPECTRA = 10\n    RHK_PAGE_IV_4x4 = 11\n    RHK_PAGE_IV_8x8 = 12\n    RHK_PAGE_IV_16x16 = 13\n    RHK_PAGE_IV_32x32 = 14\n    RHK_PAGE_IV_CENTER = 15\n    RHK_PAGE_INTERACTIVE_SPECTRA = 16\n    RHK_PAGE_AUTOCORRELATION = 17\n    RHK_PAGE_IZ_SPECTRA = 18\n    RHK_PAGE_4_GAIN_TOPOGRAPHY = 19\n    RHK_PAGE_8_GAIN_TOPOGRAPHY = 20\n    RHK_PAGE_4_GAIN_CURRENT = 21\n    RHK_PAGE_8_GAIN_CURRENT = 22\n    RHK_PAGE_IV_64x64 = 23\n    RHK_PAGE_AUTOCORRELATION_SPECTRUM = 24\n    RHK_PAGE_COUNTER = 25\n    RHK_PAGE_MULTICHANNEL_ANALYSER = 26\n    RHK_PAGE_AFM_100 = 27\n    RHK_PAGE_CITS = 28\n    RHK_PAGE_GPIB = 29\n    RHK_PAGE_VIDEO_CHANNEL = 30\n    RHK_PAGE_IMAGE_OUT_SPECTRA = 31\n    RHK_PAGE_I_DATALOG = 32\n    RHK_PAGE_I_ECSET = 33\n    RHK_PAGE_I_ECDATA = 34\n    RHK_PAGE_I_DSP_AD = 35\n    RHK_PAGE_DISCRETE_SPECTROSCOPY_PP = 36\n    RHK_PAGE_IMAGE_DISCRETE_SPECTROSCOPY = 37\n    RHK_PAGE_RAMP_SPECTROSCOPY_RP = 38\n    RHK_PAGE_DISCRETE_SPECTROSCOPY_RP = 39\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkScanType","title":"<code>RhkScanType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of Scans</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class RhkScanType(Enum):\n    \"\"\"Types of Scans\"\"\"\n\n    RHK_SCAN_RIGHT = 0\n    RHK_SCAN_LEFT = 1\n    RHK_SCAN_UP = 2\n    RHK_SCAN_DOWN = 3\n\n    def direction(self) -&gt; str:\n        \"\"\"Get the scan direction as string\"\"\"\n        if self == RhkScanType.RHK_SCAN_RIGHT:\n            return \"right\"\n        elif self == RhkScanType.RHK_SCAN_LEFT:\n            return \"left\"\n        elif self == RhkScanType.RHK_SCAN_UP:\n            return \"up\"\n        elif self == RhkScanType.RHK_SCAN_DOWN:\n            return \"down\"\n        else:\n            return \"unknown\"\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkScanType-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.RhkScanType.direction","title":"<code>direction()</code>","text":"<p>Get the scan direction as string</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>def direction(self) -&gt; str:\n    \"\"\"Get the scan direction as string\"\"\"\n    if self == RhkScanType.RHK_SCAN_RIGHT:\n        return \"right\"\n    elif self == RhkScanType.RHK_SCAN_LEFT:\n        return \"left\"\n    elif self == RhkScanType.RHK_SCAN_UP:\n        return \"up\"\n    elif self == RhkScanType.RHK_SCAN_DOWN:\n        return \"down\"\n    else:\n        return \"unknown\"\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileAll","title":"<code>Sm4FileAll</code>","text":"<p>Class representing an entire SM4-file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The SM4-file to be parsed</p> required <p>Attributes:</p> Name Type Description <code>filepath</code> <p>The SM4-file to be parsed</p> <code>file_header</code> <p>The file's header</p> <code>pages</code> <p>The files pages. A page is measurement channel</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>class Sm4FileAll:\n    \"\"\"Class representing an entire SM4-file\n\n    Args:\n        filepath: The SM4-file to be parsed\n\n    Attributes:\n        filepath: The SM4-file to be parsed\n        file_header: The file's header\n        pages: The files pages. A page is measurement channel\n    \"\"\"\n\n    def __init__(self, filepath: str):\n        self.filepath = filepath\n        with open(filepath, \"rb\") as f:\n            self.read_sm4_file(f)\n\n    def read_sm4_file(self, f: BufferedReader) -&gt; None:\n        \"\"\"Main function for parsing a SM4-file\n\n        Args:\n            f: File buffer of the file to parse\n        \"\"\"\n        cursor = Cursor(f)\n        self.file_header = Sm4FileHeader.from_buffer(cursor)\n        self.file_header.read_objects(cursor)\n        page_index_header = self.file_header.page_index_header\n\n        page_index_array_offset = page_index_header.page_index_array_offset()\n        assert page_index_array_offset\n        cursor.set_position(page_index_array_offset)\n\n        self.pages: List[Sm4Page] = []\n        for _ in range(page_index_header.page_count):\n            page = Sm4Page.from_buffer(cursor)\n            self.pages.append(page)\n\n        offset = None\n        for page in self.pages:\n            for obj in page.object_list:\n                if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_HEADER:\n                    offset = obj.offset\n                    break\n            if offset is None:\n                raise BufferError(f\"No page header in page\")\n            cursor.set_position(offset)\n\n            if page.page_data_type == RhkPageDataType.RHK_DATA_SEQUENTIAL:\n                page_header: Sm4PageHeader = (\n                    Sm4PageHeaderSequential.from_buffer(cursor)\n                )\n\n            else:\n                page_header = Sm4PageHeaderDefault.from_buffer(cursor)\n                page_header.read_data(cursor)\n\n            page.add_header(page_header)\n            page.read_label()\n            page.read_data(cursor)\n\n        self.arrange_data()\n\n    def arrange_data(self) -&gt; None:\n        \"\"\"Arrange the data array depending on type of the Page\n\n        - if Image: arrange that 2D array starts with upper left pixel\n        - if Line: arrange array with first column for x-values and following\n            columns y-values\n        \"\"\"\n        for page in self.pages:\n            if type(page.header) == Sm4PageHeaderDefault:\n                page.data.data = page.data.data.reshape(\n                    page.header.y_size, page.header.x_size\n                )\n\n                if page.page_data_type == RhkPageDataType.RHK_DATA_IMAGE:\n                    if page.header.x_scale &lt; 0:\n                        page.data.data = np.flip(page.data.data, axis=1)\n                    if page.header.y_scale &gt; 0:\n                        page.data.data = np.flip(page.data.data, axis=0)\n\n                elif page.page_data_type == RhkPageDataType.RHK_DATA_LINE:\n                    x_values = (\n                        np.arange(page.header.x_size) * page.header.x_scale\n                        + page.header.x_offset\n                    )\n                    y_values_arr = page.data.data.transpose()\n                    page.data.data = np.column_stack((x_values, y_values_arr))\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileAll-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileAll.arrange_data","title":"<code>arrange_data()</code>","text":"<p>Arrange the data array depending on type of the Page</p> <ul> <li>if Image: arrange that 2D array starts with upper left pixel</li> <li>if Line: arrange array with first column for x-values and following     columns y-values</li> </ul> Source code in <code>sm4file/sm4_file.py</code> <pre><code>def arrange_data(self) -&gt; None:\n    \"\"\"Arrange the data array depending on type of the Page\n\n    - if Image: arrange that 2D array starts with upper left pixel\n    - if Line: arrange array with first column for x-values and following\n        columns y-values\n    \"\"\"\n    for page in self.pages:\n        if type(page.header) == Sm4PageHeaderDefault:\n            page.data.data = page.data.data.reshape(\n                page.header.y_size, page.header.x_size\n            )\n\n            if page.page_data_type == RhkPageDataType.RHK_DATA_IMAGE:\n                if page.header.x_scale &lt; 0:\n                    page.data.data = np.flip(page.data.data, axis=1)\n                if page.header.y_scale &gt; 0:\n                    page.data.data = np.flip(page.data.data, axis=0)\n\n            elif page.page_data_type == RhkPageDataType.RHK_DATA_LINE:\n                x_values = (\n                    np.arange(page.header.x_size) * page.header.x_scale\n                    + page.header.x_offset\n                )\n                y_values_arr = page.data.data.transpose()\n                page.data.data = np.column_stack((x_values, y_values_arr))\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileAll.read_sm4_file","title":"<code>read_sm4_file(f)</code>","text":"<p>Main function for parsing a SM4-file</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>BufferedReader</code> <p>File buffer of the file to parse</p> required Source code in <code>sm4file/sm4_file.py</code> <pre><code>def read_sm4_file(self, f: BufferedReader) -&gt; None:\n    \"\"\"Main function for parsing a SM4-file\n\n    Args:\n        f: File buffer of the file to parse\n    \"\"\"\n    cursor = Cursor(f)\n    self.file_header = Sm4FileHeader.from_buffer(cursor)\n    self.file_header.read_objects(cursor)\n    page_index_header = self.file_header.page_index_header\n\n    page_index_array_offset = page_index_header.page_index_array_offset()\n    assert page_index_array_offset\n    cursor.set_position(page_index_array_offset)\n\n    self.pages: List[Sm4Page] = []\n    for _ in range(page_index_header.page_count):\n        page = Sm4Page.from_buffer(cursor)\n        self.pages.append(page)\n\n    offset = None\n    for page in self.pages:\n        for obj in page.object_list:\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_HEADER:\n                offset = obj.offset\n                break\n        if offset is None:\n            raise BufferError(f\"No page header in page\")\n        cursor.set_position(offset)\n\n        if page.page_data_type == RhkPageDataType.RHK_DATA_SEQUENTIAL:\n            page_header: Sm4PageHeader = (\n                Sm4PageHeaderSequential.from_buffer(cursor)\n            )\n\n        else:\n            page_header = Sm4PageHeaderDefault.from_buffer(cursor)\n            page_header.read_data(cursor)\n\n        page.add_header(page_header)\n        page.read_label()\n        page.read_data(cursor)\n\n    self.arrange_data()\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileHeader","title":"<code>Sm4FileHeader</code>  <code>dataclass</code>","text":"<p>Class representing the file header of a SM4-file</p> <p>Its object_list contains PAGE_INDEX_ARRAY, PRM, PRM_HEADER</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@dataclass\nclass Sm4FileHeader:\n    \"\"\"Class representing the file header of a SM4-file\n\n    Its object_list contains PAGE_INDEX_ARRAY, PRM, PRM_HEADER\n    \"\"\"\n\n    size: int\n    signature: str\n    page_count: int\n    object_list_count: int\n    object_field_size: int\n    object_list: List[Sm4Object]\n    page_index_header: Sm4PageIndexHeader = field(init=False)\n    prm_header: PrmHeader = field(init=False)\n    prm: Prm = field(init=False)\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; Sm4FileHeader:\n        \"\"\"Creates a [`Sm4Object`][sm4file.sm4_file.Sm4Object] from a buffer\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`Sm4FileHeader`][sm4file.sm4_file.Sm4FileHeader]\n        \"\"\"\n        size = cursor.read_u16_le()\n        signature = cursor.read_string(36)\n        page_count = cursor.read_u32_le()\n        object_list_count = cursor.read_u32_le()\n        object_field_size = cursor.read_u32_le()\n\n        _ = cursor.read_u32_le()\n        _ = cursor.read_u32_le()\n\n        object_list: List[Sm4Object] = []\n        for _ in range(object_list_count):\n            obj = Sm4Object.from_buffer(cursor)\n            \"\"\" print(obj) \"\"\"\n            object_list.append(obj)\n\n        return cls(\n            size,\n            signature,\n            page_count,\n            object_list_count,\n            object_field_size,\n            object_list,\n        )\n\n    def read_objects(self, cursor: Cursor) -&gt; None:\n        \"\"\"Read the objects of [`Sm4FileHeader`s][sm4file.sm4_file.Sm4FileHeader]\n        into the fields `page_index_header`, `prm_header` and `prm`\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        \"\"\"\n        # read the PRM header first\n        self.read_prm_header(cursor)\n        if self.prm_header is None:\n            raise BufferError(\"No PRM header in file header\")\n\n        for obj in self.object_list:\n            cursor.set_position(obj.offset)\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_INDEX_HEADER:\n                self.page_index_header = Sm4PageIndexHeader.from_buffer(\n                    cursor, obj.offset\n                )\n\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_PRM:\n                self.prm = Prm.from_buffer(\n                    cursor,\n                    self.prm_header.prm_compression_flag,\n                    self.prm_header.prm_data_size,\n                    self.prm_header.prm_compression_size,\n                )\n\n    def read_prm_header(self, cursor: Cursor) -&gt; None:\n        \"\"\"Read the PRM Header into the `prm_header` field\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        \"\"\"\n        for obj in self.object_list:\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_PRM_HEADER:\n                cursor.set_position(obj.offset)\n                self.prm_header = PrmHeader.from_buffer(cursor)\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileHeader-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileHeader.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Creates a <code>Sm4Object</code> from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>Sm4FileHeader</code> <p>The parsed <code>Sm4FileHeader</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; Sm4FileHeader:\n    \"\"\"Creates a [`Sm4Object`][sm4file.sm4_file.Sm4Object] from a buffer\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`Sm4FileHeader`][sm4file.sm4_file.Sm4FileHeader]\n    \"\"\"\n    size = cursor.read_u16_le()\n    signature = cursor.read_string(36)\n    page_count = cursor.read_u32_le()\n    object_list_count = cursor.read_u32_le()\n    object_field_size = cursor.read_u32_le()\n\n    _ = cursor.read_u32_le()\n    _ = cursor.read_u32_le()\n\n    object_list: List[Sm4Object] = []\n    for _ in range(object_list_count):\n        obj = Sm4Object.from_buffer(cursor)\n        \"\"\" print(obj) \"\"\"\n        object_list.append(obj)\n\n    return cls(\n        size,\n        signature,\n        page_count,\n        object_list_count,\n        object_field_size,\n        object_list,\n    )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileHeader.read_objects","title":"<code>read_objects(cursor)</code>","text":"<p>Read the objects of <code>Sm4FileHeader</code>s into the fields <code>page_index_header</code>, <code>prm_header</code> and <code>prm</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required Source code in <code>sm4file/sm4_file.py</code> <pre><code>def read_objects(self, cursor: Cursor) -&gt; None:\n    \"\"\"Read the objects of [`Sm4FileHeader`s][sm4file.sm4_file.Sm4FileHeader]\n    into the fields `page_index_header`, `prm_header` and `prm`\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n    \"\"\"\n    # read the PRM header first\n    self.read_prm_header(cursor)\n    if self.prm_header is None:\n        raise BufferError(\"No PRM header in file header\")\n\n    for obj in self.object_list:\n        cursor.set_position(obj.offset)\n        if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_INDEX_HEADER:\n            self.page_index_header = Sm4PageIndexHeader.from_buffer(\n                cursor, obj.offset\n            )\n\n        if obj.obj_type == RhkObjectType.RHK_OBJECT_PRM:\n            self.prm = Prm.from_buffer(\n                cursor,\n                self.prm_header.prm_compression_flag,\n                self.prm_header.prm_data_size,\n                self.prm_header.prm_compression_size,\n            )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4FileHeader.read_prm_header","title":"<code>read_prm_header(cursor)</code>","text":"<p>Read the PRM Header into the <code>prm_header</code> field</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required Source code in <code>sm4file/sm4_file.py</code> <pre><code>def read_prm_header(self, cursor: Cursor) -&gt; None:\n    \"\"\"Read the PRM Header into the `prm_header` field\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n    \"\"\"\n    for obj in self.object_list:\n        if obj.obj_type == RhkObjectType.RHK_OBJECT_PRM_HEADER:\n            cursor.set_position(obj.offset)\n            self.prm_header = PrmHeader.from_buffer(cursor)\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Object","title":"<code>Sm4Object</code>  <code>dataclass</code>","text":"<p>Class for indentifying an Object</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@dataclass\nclass Sm4Object:\n    \"\"\"Class for indentifying an Object\"\"\"\n\n    obj_type: RhkObjectType\n    offset: int\n    size: int\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; Sm4Object:\n        \"\"\"Creates a [`Sm4Object`][sm4file.sm4_file.Sm4Object] from a buffer\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`Sm4Object`][sm4file.sm4_file.Sm4Object]\n        \"\"\"\n        object_type_id = RhkObjectType(cursor.read_u32_le())\n        offset = cursor.read_u32_le()\n        size = cursor.read_u32_le()\n        return cls(object_type_id, offset, size)\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Object-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Object.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Creates a <code>Sm4Object</code> from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>Sm4Object</code> <p>The parsed <code>Sm4Object</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; Sm4Object:\n    \"\"\"Creates a [`Sm4Object`][sm4file.sm4_file.Sm4Object] from a buffer\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`Sm4Object`][sm4file.sm4_file.Sm4Object]\n    \"\"\"\n    object_type_id = RhkObjectType(cursor.read_u32_le())\n    offset = cursor.read_u32_le()\n    size = cursor.read_u32_le()\n    return cls(object_type_id, offset, size)\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Page","title":"<code>Sm4Page</code>  <code>dataclass</code>","text":"<p>Class representing a Page in an SM4-file Its object_list contains PAGE_HEADER, PAGE_DATA, THUMBNAIL and THUMBNAIL_HEADER</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@dataclass\nclass Sm4Page:\n    \"\"\"Class representing a Page in an SM4-file\n    Its object_list contains PAGE_HEADER, PAGE_DATA, THUMBNAIL and\n    THUMBNAIL_HEADER\n    \"\"\"\n\n    header: Sm4PageHeader = field(init=False)\n    data: PageData = field(init=False)\n    label: str = field(init=False)\n    page_id: int\n    page_data_type: RhkPageDataType\n    page_source_type: RhkPageSourceType\n    object_list_count: int\n    minor_version: int\n    object_list: List[Sm4Object]\n    page_objects: List[PageHeaderObject] = field(default_factory=list)\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; Sm4Page:\n        \"\"\"Read a Page from a buffer\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`Sm4Page`][sm4file.sm4_file.Sm4Page]\n        \"\"\"\n        page_id = cursor.read_u16_le()\n        cursor.skip(14)\n        page_data_type = RhkPageDataType(cursor.read_u32_le())\n        page_source_type = RhkPageSourceType(cursor.read_u32_le())\n        object_list_count = cursor.read_u32_le()\n        minor_version = cursor.read_u32_le()\n\n        object_list = []\n        for _ in range(object_list_count):\n            object_list.append(Sm4Object.from_buffer(cursor))\n\n        return cls(\n            page_id,\n            page_data_type,\n            page_source_type,\n            minor_version,\n            object_list_count,\n            object_list,\n        )\n\n    def add_header(self, header: Sm4PageHeader) -&gt; None:\n        \"\"\"Adds a [`Sm4PageHeader`][sm4file.sm4_file.Sm4PageHeader] to the page\n\n        Args:\n            header: The [`Sm4PageHeader`][sm4file.sm4_file.Sm4PageHeader] to\n                be added\n        \"\"\"\n        self.header = header\n\n    def read_data(self, cursor: Cursor) -&gt; None:\n        \"\"\"Read the Page's Page Data of the `objects_list` into `data`\n\n        Todo:\n            Parsing of the Thumbnail data is not supported\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        \"\"\"\n        for obj in self.object_list:\n            if (\n                obj.offset != 0\n                and obj.size != 0\n                and isinstance(self.header, Sm4PageHeaderDefault)\n            ):\n                cursor.set_position(obj.offset)\n\n                if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_DATA:\n                    self.data = PageData.from_buffer(\n                        cursor,\n                        obj.size,\n                        self.header.z_scale,\n                        self.header.z_offset,\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL:\n                    pass\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL_HEADER:\n                    pass\n\n    def read_label(self) -&gt; None:\n        \"\"\"Reads the Page's label from the Header's\n        [`StringData`][sm4file.sm4_object_types.StringData] into `label`\n        \"\"\"\n        if type(self.header) == Sm4PageHeaderDefault:\n            for obj in self.header.page_header_objects:\n                if type(obj) == StringData:\n                    self.label = obj.label\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Page-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Page.add_header","title":"<code>add_header(header)</code>","text":"<p>Adds a <code>Sm4PageHeader</code> to the page</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>Sm4PageHeader</code> <p>The <code>Sm4PageHeader</code> to be added</p> required Source code in <code>sm4file/sm4_file.py</code> <pre><code>def add_header(self, header: Sm4PageHeader) -&gt; None:\n    \"\"\"Adds a [`Sm4PageHeader`][sm4file.sm4_file.Sm4PageHeader] to the page\n\n    Args:\n        header: The [`Sm4PageHeader`][sm4file.sm4_file.Sm4PageHeader] to\n            be added\n    \"\"\"\n    self.header = header\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Page.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read a Page from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>Sm4Page</code> <p>The parsed <code>Sm4Page</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; Sm4Page:\n    \"\"\"Read a Page from a buffer\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`Sm4Page`][sm4file.sm4_file.Sm4Page]\n    \"\"\"\n    page_id = cursor.read_u16_le()\n    cursor.skip(14)\n    page_data_type = RhkPageDataType(cursor.read_u32_le())\n    page_source_type = RhkPageSourceType(cursor.read_u32_le())\n    object_list_count = cursor.read_u32_le()\n    minor_version = cursor.read_u32_le()\n\n    object_list = []\n    for _ in range(object_list_count):\n        object_list.append(Sm4Object.from_buffer(cursor))\n\n    return cls(\n        page_id,\n        page_data_type,\n        page_source_type,\n        minor_version,\n        object_list_count,\n        object_list,\n    )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Page.read_data","title":"<code>read_data(cursor)</code>","text":"<p>Read the Page's Page Data of the <code>objects_list</code> into <code>data</code></p> Todo <p>Parsing of the Thumbnail data is not supported</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required Source code in <code>sm4file/sm4_file.py</code> <pre><code>def read_data(self, cursor: Cursor) -&gt; None:\n    \"\"\"Read the Page's Page Data of the `objects_list` into `data`\n\n    Todo:\n        Parsing of the Thumbnail data is not supported\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n    \"\"\"\n    for obj in self.object_list:\n        if (\n            obj.offset != 0\n            and obj.size != 0\n            and isinstance(self.header, Sm4PageHeaderDefault)\n        ):\n            cursor.set_position(obj.offset)\n\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_DATA:\n                self.data = PageData.from_buffer(\n                    cursor,\n                    obj.size,\n                    self.header.z_scale,\n                    self.header.z_offset,\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL:\n                pass\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL_HEADER:\n                pass\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4Page.read_label","title":"<code>read_label()</code>","text":"<p>Reads the Page's label from the Header's <code>StringData</code> into <code>label</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>def read_label(self) -&gt; None:\n    \"\"\"Reads the Page's label from the Header's\n    [`StringData`][sm4file.sm4_object_types.StringData] into `label`\n    \"\"\"\n    if type(self.header) == Sm4PageHeaderDefault:\n        for obj in self.header.page_header_objects:\n            if type(obj) == StringData:\n                self.label = obj.label\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderDefault","title":"<code>Sm4PageHeaderDefault</code>  <code>dataclass</code>","text":"<p>Class representing a default Page Header</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@dataclass\nclass Sm4PageHeaderDefault:\n    \"\"\"Class representing a default Page Header\"\"\"\n\n    string_count: int\n    page_type: RhkPageType\n    data_sub_source: int\n    line_type: RhkLineType\n    x_corner: int\n    y_corner: int\n    x_size: int\n    y_size: int\n    image_type: RhkImageType\n    scan_type: RhkScanType\n    group_id: int\n    page_data_size: int\n    min_z_value: int\n    max_z_value: int\n    x_scale: float\n    y_scale: float\n    z_scale: float\n    xy_scale: float\n    x_offset: float\n    y_offset: float\n    z_offset: float\n    period: float\n    bias: float\n    current: float\n    angle: float\n    color_info_count: int\n    grid_x_size: int\n    grid_y_size: int\n    object_list_count: int\n    _32_bit_data_flag: int\n    object_list: List[Sm4Object]\n    page_header_objects: List[PageHeaderObject] = field(default_factory=list)\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; Sm4PageHeaderDefault:\n        \"\"\"Read a default Page Header from a buffer\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`Sm4PageHeaderDefault`][sm4file.sm4_file.Sm4PageHeaderSequential]\n        \"\"\"\n        _ = cursor.read_u16_le()\n        string_count = cursor.read_u16_le()\n        page_type = RhkPageType(cursor.read_u32_le())\n        data_sub_source = cursor.read_u32_le()\n\n        line_type = RhkLineType(cursor.read_u32_le())\n\n        x_corner = cursor.read_u32_le()\n        y_corner = cursor.read_u32_le()\n        x_size = cursor.read_u32_le()\n        y_size = cursor.read_u32_le()\n\n        image_type = RhkImageType(cursor.read_u32_le())\n\n        scan_type = RhkScanType(cursor.read_u32_le())\n\n        group_id = cursor.read_u32_le()\n        page_data_size = cursor.read_u32_le()\n\n        min_z_value = cursor.read_u32_le()\n        max_z_value = cursor.read_u32_le()\n\n        x_scale = cursor.read_f32_le()\n        y_scale = cursor.read_f32_le()\n        z_scale = cursor.read_f32_le()\n        xy_scale = cursor.read_f32_le()\n        x_offset = cursor.read_f32_le()\n        y_offset = cursor.read_f32_le()\n        z_offset = cursor.read_f32_le()\n        period = cursor.read_f32_le()\n        bias = cursor.read_f32_le()\n        current = cursor.read_f32_le()\n        angle = cursor.read_f32_le()\n\n        color_info_count = cursor.read_u32_le()\n        grid_x_size = cursor.read_u32_le()\n        grid_y_size = cursor.read_u32_le()\n\n        object_list_count = cursor.read_u32_le()\n        _32_bit_data_flag = cursor.read_u8_le()\n\n        # reserved\n        cursor.skip(63)\n\n        object_list: List[Sm4Object] = []\n        for _ in range(object_list_count):\n            obj = Sm4Object.from_buffer(cursor)\n            \"\"\" print(\"PageHeaderDefault : \", obj) \"\"\"\n            object_list.append(obj)\n\n        return Sm4PageHeaderDefault(\n            string_count,\n            page_type,\n            data_sub_source,\n            line_type,\n            x_corner,\n            y_corner,\n            x_size,\n            y_size,\n            image_type,\n            scan_type,\n            group_id,\n            page_data_size,\n            min_z_value,\n            max_z_value,\n            x_scale,\n            y_scale,\n            z_scale,\n            xy_scale,\n            x_offset,\n            y_offset,\n            z_offset,\n            period,\n            bias,\n            current,\n            angle,\n            color_info_count,\n            grid_x_size,\n            grid_y_size,\n            object_list_count,\n            _32_bit_data_flag,\n            object_list,\n        )\n\n    def read_data(self, cursor: Cursor) -&gt; None:\n        \"\"\"Read the objects of the object_list into page_header_objects\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        \"\"\"\n        tiptrack_info_count = None\n        for obj in self.object_list:\n            if obj.offset != 0 and obj.size != 0:\n                cursor.set_position(obj.offset)\n\n                if obj.obj_type == RhkObjectType.RHK_OBJECT_IMAGE_DRIFT_HEADER:\n                    self.page_header_objects.append(\n                        ImageDriftHeader.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_IMAGE_DRIFT:\n                    self.page_header_objects.append(\n                        ImageDriftData.from_buffer(cursor)\n                    )\n\n                elif (\n                    obj.obj_type == RhkObjectType.RHK_OBJECT_SPEC_DRIFT_HEADER\n                ):\n                    self.page_header_objects.append(\n                        SpecDriftHeader.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_SPEC_DRIFT_DATA:\n                    self.page_header_objects.append(\n                        SpecDriftData.from_buffer(cursor, self.y_size)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_COLOR_INFO:\n                    pass\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_STRING_DATA:\n                    self.page_header_objects.append(\n                        StringData.from_buffer(cursor, self.string_count)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_TIP_TRACK_HEADER:\n                    read_obj = TipTrackHeader.from_buffer(cursor)\n                    tiptrack_info_count = read_obj.tiptrack_tiptrack_info_count\n                    self.page_header_objects.append(read_obj)\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_TIP_TRACK_DATA:\n                    if tiptrack_info_count is not None:\n                        self.page_header_objects.append(\n                            TipTrackData.from_buffer(\n                                cursor, tiptrack_info_count\n                            )\n                        )\n                    else:\n                        raise ValueError(\"tiptrack_info_count not found\")\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL:\n                    pass\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL_HEADER:\n                    pass\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_API_INFO:\n                    self.page_header_objects.append(\n                        ApiInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_HISTORY_INFO:\n                    pass\n\n                elif (\n                    obj.obj_type == RhkObjectType.RHK_OBJECT_PIEZO_SENSITIVITY\n                ):\n                    self.page_header_objects.append(\n                        PiezoSensitivity.from_buffer(cursor)\n                    )\n\n                elif (\n                    obj.obj_type\n                    == RhkObjectType.RHK_OBJECT_FREQUENCY_SWEEP_DATA\n                ):\n                    self.page_header_objects.append(\n                        FrequencySweepData.from_buffer(cursor)\n                    )\n\n                elif (\n                    obj.obj_type\n                    == RhkObjectType.RHK_OBJECT_SCAN_PROCESSOR_INFO\n                ):\n                    self.page_header_objects.append(\n                        ScanProcessorInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_PLL_INFO:\n                    self.page_header_objects.append(\n                        PllInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_CH1_DRIVE_INFO:\n                    self.page_header_objects.append(\n                        ChannelDriveInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_CH2_DRIVE_INFO:\n                    self.page_header_objects.append(\n                        ChannelDriveInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_LOCKIN0_INFO:\n                    self.page_header_objects.append(\n                        LockinInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_LOCKIN1_INFO:\n                    self.page_header_objects.append(\n                        LockinInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_ZPI_INFO:\n                    self.page_header_objects.append(\n                        PiControllerInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_KPI_INFO:\n                    self.page_header_objects.append(\n                        PiControllerInfo.from_buffer(cursor)\n                    )\n\n                elif obj.obj_type == RhkObjectType.RHK_OBJECT_AUX_PI_INFO:\n                    self.page_header_objects.append(\n                        PiControllerInfo.from_buffer(cursor)\n                    )\n\n                elif (\n                    obj.obj_type\n                    == RhkObjectType.RHK_OBJECT_LOWPASS_FILTER0_INFO\n                ):\n                    self.page_header_objects.append(\n                        LowpassFilterInfo.from_buffer(cursor)\n                    )\n\n                elif (\n                    obj.obj_type\n                    == RhkObjectType.RHK_OBJECT_LOWPASS_FILTER1_INFO\n                ):\n                    self.page_header_objects.append(\n                        LowpassFilterInfo.from_buffer(cursor)\n                    )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderDefault-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderDefault.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read a default Page Header from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>Sm4PageHeaderDefault</code> <p>The parsed <code>Sm4PageHeaderDefault</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; Sm4PageHeaderDefault:\n    \"\"\"Read a default Page Header from a buffer\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`Sm4PageHeaderDefault`][sm4file.sm4_file.Sm4PageHeaderSequential]\n    \"\"\"\n    _ = cursor.read_u16_le()\n    string_count = cursor.read_u16_le()\n    page_type = RhkPageType(cursor.read_u32_le())\n    data_sub_source = cursor.read_u32_le()\n\n    line_type = RhkLineType(cursor.read_u32_le())\n\n    x_corner = cursor.read_u32_le()\n    y_corner = cursor.read_u32_le()\n    x_size = cursor.read_u32_le()\n    y_size = cursor.read_u32_le()\n\n    image_type = RhkImageType(cursor.read_u32_le())\n\n    scan_type = RhkScanType(cursor.read_u32_le())\n\n    group_id = cursor.read_u32_le()\n    page_data_size = cursor.read_u32_le()\n\n    min_z_value = cursor.read_u32_le()\n    max_z_value = cursor.read_u32_le()\n\n    x_scale = cursor.read_f32_le()\n    y_scale = cursor.read_f32_le()\n    z_scale = cursor.read_f32_le()\n    xy_scale = cursor.read_f32_le()\n    x_offset = cursor.read_f32_le()\n    y_offset = cursor.read_f32_le()\n    z_offset = cursor.read_f32_le()\n    period = cursor.read_f32_le()\n    bias = cursor.read_f32_le()\n    current = cursor.read_f32_le()\n    angle = cursor.read_f32_le()\n\n    color_info_count = cursor.read_u32_le()\n    grid_x_size = cursor.read_u32_le()\n    grid_y_size = cursor.read_u32_le()\n\n    object_list_count = cursor.read_u32_le()\n    _32_bit_data_flag = cursor.read_u8_le()\n\n    # reserved\n    cursor.skip(63)\n\n    object_list: List[Sm4Object] = []\n    for _ in range(object_list_count):\n        obj = Sm4Object.from_buffer(cursor)\n        \"\"\" print(\"PageHeaderDefault : \", obj) \"\"\"\n        object_list.append(obj)\n\n    return Sm4PageHeaderDefault(\n        string_count,\n        page_type,\n        data_sub_source,\n        line_type,\n        x_corner,\n        y_corner,\n        x_size,\n        y_size,\n        image_type,\n        scan_type,\n        group_id,\n        page_data_size,\n        min_z_value,\n        max_z_value,\n        x_scale,\n        y_scale,\n        z_scale,\n        xy_scale,\n        x_offset,\n        y_offset,\n        z_offset,\n        period,\n        bias,\n        current,\n        angle,\n        color_info_count,\n        grid_x_size,\n        grid_y_size,\n        object_list_count,\n        _32_bit_data_flag,\n        object_list,\n    )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderDefault.read_data","title":"<code>read_data(cursor)</code>","text":"<p>Read the objects of the object_list into page_header_objects</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required Source code in <code>sm4file/sm4_file.py</code> <pre><code>def read_data(self, cursor: Cursor) -&gt; None:\n    \"\"\"Read the objects of the object_list into page_header_objects\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n    \"\"\"\n    tiptrack_info_count = None\n    for obj in self.object_list:\n        if obj.offset != 0 and obj.size != 0:\n            cursor.set_position(obj.offset)\n\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_IMAGE_DRIFT_HEADER:\n                self.page_header_objects.append(\n                    ImageDriftHeader.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_IMAGE_DRIFT:\n                self.page_header_objects.append(\n                    ImageDriftData.from_buffer(cursor)\n                )\n\n            elif (\n                obj.obj_type == RhkObjectType.RHK_OBJECT_SPEC_DRIFT_HEADER\n            ):\n                self.page_header_objects.append(\n                    SpecDriftHeader.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_SPEC_DRIFT_DATA:\n                self.page_header_objects.append(\n                    SpecDriftData.from_buffer(cursor, self.y_size)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_COLOR_INFO:\n                pass\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_STRING_DATA:\n                self.page_header_objects.append(\n                    StringData.from_buffer(cursor, self.string_count)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_TIP_TRACK_HEADER:\n                read_obj = TipTrackHeader.from_buffer(cursor)\n                tiptrack_info_count = read_obj.tiptrack_tiptrack_info_count\n                self.page_header_objects.append(read_obj)\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_TIP_TRACK_DATA:\n                if tiptrack_info_count is not None:\n                    self.page_header_objects.append(\n                        TipTrackData.from_buffer(\n                            cursor, tiptrack_info_count\n                        )\n                    )\n                else:\n                    raise ValueError(\"tiptrack_info_count not found\")\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL:\n                pass\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_THUMBNAIL_HEADER:\n                pass\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_API_INFO:\n                self.page_header_objects.append(\n                    ApiInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_HISTORY_INFO:\n                pass\n\n            elif (\n                obj.obj_type == RhkObjectType.RHK_OBJECT_PIEZO_SENSITIVITY\n            ):\n                self.page_header_objects.append(\n                    PiezoSensitivity.from_buffer(cursor)\n                )\n\n            elif (\n                obj.obj_type\n                == RhkObjectType.RHK_OBJECT_FREQUENCY_SWEEP_DATA\n            ):\n                self.page_header_objects.append(\n                    FrequencySweepData.from_buffer(cursor)\n                )\n\n            elif (\n                obj.obj_type\n                == RhkObjectType.RHK_OBJECT_SCAN_PROCESSOR_INFO\n            ):\n                self.page_header_objects.append(\n                    ScanProcessorInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_PLL_INFO:\n                self.page_header_objects.append(\n                    PllInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_CH1_DRIVE_INFO:\n                self.page_header_objects.append(\n                    ChannelDriveInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_CH2_DRIVE_INFO:\n                self.page_header_objects.append(\n                    ChannelDriveInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_LOCKIN0_INFO:\n                self.page_header_objects.append(\n                    LockinInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_LOCKIN1_INFO:\n                self.page_header_objects.append(\n                    LockinInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_ZPI_INFO:\n                self.page_header_objects.append(\n                    PiControllerInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_KPI_INFO:\n                self.page_header_objects.append(\n                    PiControllerInfo.from_buffer(cursor)\n                )\n\n            elif obj.obj_type == RhkObjectType.RHK_OBJECT_AUX_PI_INFO:\n                self.page_header_objects.append(\n                    PiControllerInfo.from_buffer(cursor)\n                )\n\n            elif (\n                obj.obj_type\n                == RhkObjectType.RHK_OBJECT_LOWPASS_FILTER0_INFO\n            ):\n                self.page_header_objects.append(\n                    LowpassFilterInfo.from_buffer(cursor)\n                )\n\n            elif (\n                obj.obj_type\n                == RhkObjectType.RHK_OBJECT_LOWPASS_FILTER1_INFO\n            ):\n                self.page_header_objects.append(\n                    LowpassFilterInfo.from_buffer(cursor)\n                )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderSequential","title":"<code>Sm4PageHeaderSequential</code>  <code>dataclass</code>","text":"<p>Class representing a sequential Page Header</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@dataclass\nclass Sm4PageHeaderSequential:\n    \"\"\"Class representing a sequential Page Header\"\"\"\n\n    data_type: int\n    data_length: int\n    param_count: int\n    object_list_count: int\n    data_info_size: int\n    data_info_string_count: int\n    object_list: List[Sm4Object]\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; Sm4PageHeaderSequential:\n        \"\"\"Read a sequential Page Header from a buffer\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`Sm4PageHeaderSequential`][sm4file.sm4_file.Sm4PageHeaderSequential]\n        \"\"\"\n        data_type = cursor.read_u32_le()\n        data_length = cursor.read_u32_le()\n        param_count = cursor.read_u32_le()\n        object_list_count = cursor.read_u32_le()\n        data_info_size = cursor.read_u32_le()\n        data_info_string_count = cursor.read_u32_le()\n\n        object_list: List[Sm4Object] = []\n        for _ in range(object_list_count):\n            object_list.append(Sm4Object.from_buffer(cursor))\n\n        sequential_param_gain: List[float] = []\n        sequential_param_label: List[str] = []\n        sequential_param_unit: List[str] = []\n        for _ in range(param_count):\n            sequential_param_gain.append(cursor.read_f32_le())\n            sequential_param_label.append(cursor.read_sm4_string())\n            sequential_param_unit.append(cursor.read_sm4_string())\n\n        return Sm4PageHeaderSequential(\n            data_type,\n            data_length,\n            param_count,\n            object_list_count,\n            data_info_size,\n            data_info_string_count,\n            object_list,\n        )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderSequential-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageHeaderSequential.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read a sequential Page Header from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>Sm4PageHeaderSequential</code> <p>The parsed <code>Sm4PageHeaderSequential</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; Sm4PageHeaderSequential:\n    \"\"\"Read a sequential Page Header from a buffer\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`Sm4PageHeaderSequential`][sm4file.sm4_file.Sm4PageHeaderSequential]\n    \"\"\"\n    data_type = cursor.read_u32_le()\n    data_length = cursor.read_u32_le()\n    param_count = cursor.read_u32_le()\n    object_list_count = cursor.read_u32_le()\n    data_info_size = cursor.read_u32_le()\n    data_info_string_count = cursor.read_u32_le()\n\n    object_list: List[Sm4Object] = []\n    for _ in range(object_list_count):\n        object_list.append(Sm4Object.from_buffer(cursor))\n\n    sequential_param_gain: List[float] = []\n    sequential_param_label: List[str] = []\n    sequential_param_unit: List[str] = []\n    for _ in range(param_count):\n        sequential_param_gain.append(cursor.read_f32_le())\n        sequential_param_label.append(cursor.read_sm4_string())\n        sequential_param_unit.append(cursor.read_sm4_string())\n\n    return Sm4PageHeaderSequential(\n        data_type,\n        data_length,\n        param_count,\n        object_list_count,\n        data_info_size,\n        data_info_string_count,\n        object_list,\n    )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageIndexHeader","title":"<code>Sm4PageIndexHeader</code>  <code>dataclass</code>","text":"<p>Class representing the Page Index Header</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@dataclass\nclass Sm4PageIndexHeader:\n    \"\"\"Class representing the Page Index Header\"\"\"\n\n    offset: int\n    page_count: int\n    object_list_count: int\n    object_list: List[Sm4Object]\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor, offset: int) -&gt; Sm4PageIndexHeader:\n        \"\"\"Read the Page Index Header from a buffer\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n            offset: Offset of the Page Index Header\n\n        Returns:\n            The parsed [`Sm4PageIndexHeader`][sm4file.sm4_file.Sm4PageIndexHeader]\n        \"\"\"\n        page_count = cursor.read_u32_le()\n        object_list_count = cursor.read_u32_le()\n        _reserved_1 = cursor.read_u32_le()  # pyright: ignore\n        _reserved_2 = cursor.read_u32_le()  # pyright: ignore\n\n        object_list = []\n        for _ in range(object_list_count):\n            object_list.append(Sm4Object.from_buffer(cursor))\n\n        return Sm4PageIndexHeader(\n            offset, page_count, object_list_count, object_list\n        )\n\n    def page_index_array_offset(self) -&gt; Optional[int]:\n        \"\"\"Finds the offset of the Page Index Header in the object list\n\n        Returns:\n            The offset of the Page Index Header\n\n        Raises:\n            BufferError: If no Page Index Array can be found in the buffer\n        \"\"\"\n        for obj in self.object_list:\n            if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_INDEX_ARRAY:\n                return obj.offset\n        else:\n            raise BufferError(\"No Page Index Array found\")\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageIndexHeader-functions","title":"Functions","text":""},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageIndexHeader.from_buffer","title":"<code>from_buffer(cursor, offset)</code>  <code>classmethod</code>","text":"<p>Read the Page Index Header from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <code>offset</code> <code>int</code> <p>Offset of the Page Index Header</p> required <p>Returns:</p> Type Description <code>Sm4PageIndexHeader</code> <p>The parsed <code>Sm4PageIndexHeader</code></p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor, offset: int) -&gt; Sm4PageIndexHeader:\n    \"\"\"Read the Page Index Header from a buffer\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        offset: Offset of the Page Index Header\n\n    Returns:\n        The parsed [`Sm4PageIndexHeader`][sm4file.sm4_file.Sm4PageIndexHeader]\n    \"\"\"\n    page_count = cursor.read_u32_le()\n    object_list_count = cursor.read_u32_le()\n    _reserved_1 = cursor.read_u32_le()  # pyright: ignore\n    _reserved_2 = cursor.read_u32_le()  # pyright: ignore\n\n    object_list = []\n    for _ in range(object_list_count):\n        object_list.append(Sm4Object.from_buffer(cursor))\n\n    return Sm4PageIndexHeader(\n        offset, page_count, object_list_count, object_list\n    )\n</code></pre>"},{"location":"api-dev/sm4_file_all/#sm4file.sm4_file.Sm4PageIndexHeader.page_index_array_offset","title":"<code>page_index_array_offset()</code>","text":"<p>Finds the offset of the Page Index Header in the object list</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The offset of the Page Index Header</p> <p>Raises:</p> Type Description <code>BufferError</code> <p>If no Page Index Array can be found in the buffer</p> Source code in <code>sm4file/sm4_file.py</code> <pre><code>def page_index_array_offset(self) -&gt; Optional[int]:\n    \"\"\"Finds the offset of the Page Index Header in the object list\n\n    Returns:\n        The offset of the Page Index Header\n\n    Raises:\n        BufferError: If no Page Index Array can be found in the buffer\n    \"\"\"\n    for obj in self.object_list:\n        if obj.obj_type == RhkObjectType.RHK_OBJECT_PAGE_INDEX_ARRAY:\n            return obj.offset\n    else:\n        raise BufferError(\"No Page Index Array found\")\n</code></pre>"},{"location":"api-dev/sm4_object_types/","title":"Object type","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types","title":"<code>sm4file.sm4_object_types</code>","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types-classes","title":"Classes","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ApiInfo","title":"<code>ApiInfo</code>  <code>dataclass</code>","text":"<p>Class for API Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass ApiInfo:\n    \"\"\"Class for API Info\"\"\"\n\n    voltage_high: float\n    voltage_low: float\n    gain: float\n    api_offset: float\n    ramp_mode: int\n    ramp_type: int\n    step: int\n    image_count: int\n    dac: int\n    mux: int\n    bias: int\n    units: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; ApiInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`ApiInfo`][sm4file.sm4_object_types.ApiInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`ApiInfo`][sm4file.sm4_object_types.ApiInfo]\n        \"\"\"\n        voltage_high = cursor.read_f32_le()\n        voltage_low = cursor.read_f32_le()\n        gain = cursor.read_f32_le()\n        api_offset = cursor.read_f32_le()\n\n        ramp_mode = cursor.read_u32_le()\n        ramp_type = cursor.read_u32_le()\n        step = cursor.read_u32_le()\n        image_count = cursor.read_u32_le()\n        dac = cursor.read_u32_le()\n        mux = cursor.read_u32_le()\n        bias = cursor.read_u32_le()\n\n        _ = cursor.read_u32_le()\n        units = cursor.read_sm4_string()\n\n        return cls(\n            voltage_high,\n            voltage_low,\n            gain,\n            api_offset,\n            ramp_mode,\n            ramp_type,\n            step,\n            image_count,\n            dac,\n            mux,\n            bias,\n            units,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ApiInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ApiInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>ApiInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>ApiInfo</code> <p>The parsed <code>ApiInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; ApiInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`ApiInfo`][sm4file.sm4_object_types.ApiInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`ApiInfo`][sm4file.sm4_object_types.ApiInfo]\n    \"\"\"\n    voltage_high = cursor.read_f32_le()\n    voltage_low = cursor.read_f32_le()\n    gain = cursor.read_f32_le()\n    api_offset = cursor.read_f32_le()\n\n    ramp_mode = cursor.read_u32_le()\n    ramp_type = cursor.read_u32_le()\n    step = cursor.read_u32_le()\n    image_count = cursor.read_u32_le()\n    dac = cursor.read_u32_le()\n    mux = cursor.read_u32_le()\n    bias = cursor.read_u32_le()\n\n    _ = cursor.read_u32_le()\n    units = cursor.read_sm4_string()\n\n    return cls(\n        voltage_high,\n        voltage_low,\n        gain,\n        api_offset,\n        ramp_mode,\n        ramp_type,\n        step,\n        image_count,\n        dac,\n        mux,\n        bias,\n        units,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ChannelDriveInfo","title":"<code>ChannelDriveInfo</code>  <code>dataclass</code>","text":"<p>Class for Channel Drive Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass ChannelDriveInfo:\n    \"\"\"Class for Channel Drive Info\"\"\"\n\n    master_osciallator: int\n    amplitude: float\n    frequency: float\n    phase_offset: float\n    harmonic_factor: float\n    amplitude_unit: str\n    frequency_unit: str\n    phase_offset_unit: str\n    harmonic_factor_unit: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; ChannelDriveInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`ChannelDriveInfo`][sm4file.sm4_object_types.ChannelDriveInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`ChannelDriveInfo`][sm4file.sm4_object_types.ChannelDriveInfo]\n        \"\"\"\n        _ = cursor.read_u32_le()\n        master_osciallator = cursor.read_u32_le()\n        amplitude = cursor.read_f64_le()\n        frequency = cursor.read_f64_le()\n        phase_offset = cursor.read_f64_le()\n        harmonic_factor = cursor.read_f64_le()\n        amplitude_unit = cursor.read_sm4_string()\n        frequency_unit = cursor.read_sm4_string()\n        phase_offset_unit = cursor.read_sm4_string()\n        harmonic_factor_unit = cursor.read_sm4_string()\n\n        return cls(\n            master_osciallator,\n            amplitude,\n            frequency,\n            phase_offset,\n            harmonic_factor,\n            amplitude_unit,\n            frequency_unit,\n            phase_offset_unit,\n            harmonic_factor_unit,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ChannelDriveInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ChannelDriveInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>ChannelDriveInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>ChannelDriveInfo</code> <p>The parsed <code>ChannelDriveInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; ChannelDriveInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`ChannelDriveInfo`][sm4file.sm4_object_types.ChannelDriveInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`ChannelDriveInfo`][sm4file.sm4_object_types.ChannelDriveInfo]\n    \"\"\"\n    _ = cursor.read_u32_le()\n    master_osciallator = cursor.read_u32_le()\n    amplitude = cursor.read_f64_le()\n    frequency = cursor.read_f64_le()\n    phase_offset = cursor.read_f64_le()\n    harmonic_factor = cursor.read_f64_le()\n    amplitude_unit = cursor.read_sm4_string()\n    frequency_unit = cursor.read_sm4_string()\n    phase_offset_unit = cursor.read_sm4_string()\n    harmonic_factor_unit = cursor.read_sm4_string()\n\n    return cls(\n        master_osciallator,\n        amplitude,\n        frequency,\n        phase_offset,\n        harmonic_factor,\n        amplitude_unit,\n        frequency_unit,\n        phase_offset_unit,\n        harmonic_factor_unit,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.FrequencySweepData","title":"<code>FrequencySweepData</code>  <code>dataclass</code>","text":"<p>Class for Frequency Sweep Data</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass FrequencySweepData:\n    \"\"\"Class for Frequency Sweep Data\"\"\"\n\n    psd_total_signal: float\n    peak_frequency: float\n    peak_amplitude: float\n    drive_aplitude: float\n    signal_to_drive_ratio: float\n    q_factor: float\n    total_signal_unit: str\n    peak_frequency_unit: str\n    peak_amplitude_unit: str\n    drive_amplitude_unit: str\n    signal_to_drive_ratio_unit: str\n    q_factor_unit: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; FrequencySweepData:\n        \"\"\"Read the buffer's bytes into a\n        [`FrequencySweepData`][sm4file.sm4_object_types.FrequencySweepData]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`FrequencySweepData`][sm4file.sm4_object_types.FrequencySweepData]\n        \"\"\"\n        psd_total_signal = cursor.read_f64_le()\n        peak_frequency = cursor.read_f64_le()\n        peak_amplitude = cursor.read_f64_le()\n        drive_aplitude = cursor.read_f64_le()\n        signal_to_drive_ratio = cursor.read_f64_le()\n        q_factor = cursor.read_f64_le()\n\n        _ = cursor.read_u32_le()\n\n        total_signal_unit = cursor.read_sm4_string()\n        peak_frequency_unit = cursor.read_sm4_string()\n        peak_amplitude_unit = cursor.read_sm4_string()\n        drive_amplitude_unit = cursor.read_sm4_string()\n        signal_to_drive_ratio_unit = cursor.read_sm4_string()\n        q_factor_unit = cursor.read_sm4_string()\n\n        return cls(\n            psd_total_signal,\n            peak_frequency,\n            peak_amplitude,\n            drive_aplitude,\n            signal_to_drive_ratio,\n            q_factor,\n            total_signal_unit,\n            peak_frequency_unit,\n            peak_amplitude_unit,\n            drive_amplitude_unit,\n            signal_to_drive_ratio_unit,\n            q_factor_unit,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.FrequencySweepData-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.FrequencySweepData.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>FrequencySweepData</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>FrequencySweepData</code> <p>The parsed <code>FrequencySweepData</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; FrequencySweepData:\n    \"\"\"Read the buffer's bytes into a\n    [`FrequencySweepData`][sm4file.sm4_object_types.FrequencySweepData]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`FrequencySweepData`][sm4file.sm4_object_types.FrequencySweepData]\n    \"\"\"\n    psd_total_signal = cursor.read_f64_le()\n    peak_frequency = cursor.read_f64_le()\n    peak_amplitude = cursor.read_f64_le()\n    drive_aplitude = cursor.read_f64_le()\n    signal_to_drive_ratio = cursor.read_f64_le()\n    q_factor = cursor.read_f64_le()\n\n    _ = cursor.read_u32_le()\n\n    total_signal_unit = cursor.read_sm4_string()\n    peak_frequency_unit = cursor.read_sm4_string()\n    peak_amplitude_unit = cursor.read_sm4_string()\n    drive_amplitude_unit = cursor.read_sm4_string()\n    signal_to_drive_ratio_unit = cursor.read_sm4_string()\n    q_factor_unit = cursor.read_sm4_string()\n\n    return cls(\n        psd_total_signal,\n        peak_frequency,\n        peak_amplitude,\n        drive_aplitude,\n        signal_to_drive_ratio,\n        q_factor,\n        total_signal_unit,\n        peak_frequency_unit,\n        peak_amplitude_unit,\n        drive_amplitude_unit,\n        signal_to_drive_ratio_unit,\n        q_factor_unit,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ImageDriftData","title":"<code>ImageDriftData</code>  <code>dataclass</code>","text":"<p>Class for Image Drift Data</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass ImageDriftData:\n    \"\"\"Class for Image Drift Data\"\"\"\n\n    imagedrift_time: int\n    imagedrift_dx: int\n    imagedrift_dy: int\n    imagedrift_cumulative_x: int\n    imagedrift_cumulative_y: int\n    imagedrift_vector_x: int\n    imagedrift_vector_y: int\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; ImageDriftData:\n        \"\"\"Read the buffer's bytes into a\n        [`ImageDriftData`][sm4file.sm4_object_types.ImageDriftData]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`ImageDriftData`][sm4file.sm4_object_types.ImageDriftData]\n        \"\"\"\n        imagedrift_time = cursor.read_u32_le()\n        imagedrift_dx = cursor.read_u32_le()\n        imagedrift_dy = cursor.read_u32_le()\n        imagedrift_cumulative_x = cursor.read_u32_le()\n        imagedrift_cumulative_y = cursor.read_u32_le()\n        imagedrift_vector_x = cursor.read_u32_le()\n        imagedrift_vector_y = cursor.read_u32_le()\n\n        return cls(\n            imagedrift_time,\n            imagedrift_dx,\n            imagedrift_dy,\n            imagedrift_cumulative_x,\n            imagedrift_cumulative_y,\n            imagedrift_vector_x,\n            imagedrift_vector_y,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ImageDriftData-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ImageDriftData.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>ImageDriftData</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>ImageDriftData</code> <p>The parsed <code>ImageDriftData</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; ImageDriftData:\n    \"\"\"Read the buffer's bytes into a\n    [`ImageDriftData`][sm4file.sm4_object_types.ImageDriftData]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`ImageDriftData`][sm4file.sm4_object_types.ImageDriftData]\n    \"\"\"\n    imagedrift_time = cursor.read_u32_le()\n    imagedrift_dx = cursor.read_u32_le()\n    imagedrift_dy = cursor.read_u32_le()\n    imagedrift_cumulative_x = cursor.read_u32_le()\n    imagedrift_cumulative_y = cursor.read_u32_le()\n    imagedrift_vector_x = cursor.read_u32_le()\n    imagedrift_vector_y = cursor.read_u32_le()\n\n    return cls(\n        imagedrift_time,\n        imagedrift_dx,\n        imagedrift_dy,\n        imagedrift_cumulative_x,\n        imagedrift_cumulative_y,\n        imagedrift_vector_x,\n        imagedrift_vector_y,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ImageDriftHeader","title":"<code>ImageDriftHeader</code>  <code>dataclass</code>","text":"<p>Class for Image Drift Header</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass ImageDriftHeader:\n    \"\"\"Class for Image Drift Header\"\"\"\n\n    imagedrift_filetime: int\n    imagedrift_drift_option_type: RhkDriftOptionType\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; ImageDriftHeader:\n        \"\"\"Read the buffer's bytes into a\n        [`ImageDriftHeader`][sm4file.sm4_object_types.ImageDriftHeader]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`ImageDriftHeader`][sm4file.sm4_object_types.ImageDriftHeader]\n        \"\"\"\n        imagedrift_filetime = cursor.read_u64_le()\n        imagedrift_drift_option_type = RhkDriftOptionType(cursor.read_u32_le())\n\n        return cls(imagedrift_filetime, imagedrift_drift_option_type)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ImageDriftHeader-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ImageDriftHeader.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>ImageDriftHeader</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>ImageDriftHeader</code> <p>The parsed <code>ImageDriftHeader</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; ImageDriftHeader:\n    \"\"\"Read the buffer's bytes into a\n    [`ImageDriftHeader`][sm4file.sm4_object_types.ImageDriftHeader]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`ImageDriftHeader`][sm4file.sm4_object_types.ImageDriftHeader]\n    \"\"\"\n    imagedrift_filetime = cursor.read_u64_le()\n    imagedrift_drift_option_type = RhkDriftOptionType(cursor.read_u32_le())\n\n    return cls(imagedrift_filetime, imagedrift_drift_option_type)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.LockinInfo","title":"<code>LockinInfo</code>  <code>dataclass</code>","text":"<p>Class for Lockin Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass LockinInfo:\n    \"\"\"Class for Lockin Info\"\"\"\n\n    num_strings: int\n    non_master_oscillator: int\n    frequency: float\n    harmonic_factor: float\n    phase_offset: float\n    # these might be not included\n    filter_cutoff_frequency: str\n    frequency_unit: str\n    phase_unit: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; LockinInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`LockinInfo`][sm4file.sm4_object_types.LockinInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`LockinInfo`][sm4file.sm4_object_types.LockinInfo]\n        \"\"\"\n        num_strings = cursor.read_u32_le()\n\n        non_master_oscillator = cursor.read_u32_le()\n        frequency = cursor.read_f64_le()\n        harmonic_factor = cursor.read_f64_le()\n        phase_offset = cursor.read_f64_le()\n        # these might be not included\n        filter_cutoff_frequency = cursor.read_sm4_string()\n        frequency_unit = cursor.read_sm4_string()\n        phase_unit = cursor.read_sm4_string()\n\n        return cls(\n            num_strings,\n            non_master_oscillator,\n            frequency,\n            harmonic_factor,\n            phase_offset,\n            filter_cutoff_frequency,\n            frequency_unit,\n            phase_unit,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.LockinInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.LockinInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>LockinInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>LockinInfo</code> <p>The parsed <code>LockinInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; LockinInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`LockinInfo`][sm4file.sm4_object_types.LockinInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`LockinInfo`][sm4file.sm4_object_types.LockinInfo]\n    \"\"\"\n    num_strings = cursor.read_u32_le()\n\n    non_master_oscillator = cursor.read_u32_le()\n    frequency = cursor.read_f64_le()\n    harmonic_factor = cursor.read_f64_le()\n    phase_offset = cursor.read_f64_le()\n    # these might be not included\n    filter_cutoff_frequency = cursor.read_sm4_string()\n    frequency_unit = cursor.read_sm4_string()\n    phase_unit = cursor.read_sm4_string()\n\n    return cls(\n        num_strings,\n        non_master_oscillator,\n        frequency,\n        harmonic_factor,\n        phase_offset,\n        filter_cutoff_frequency,\n        frequency_unit,\n        phase_unit,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.LowpassFilterInfo","title":"<code>LowpassFilterInfo</code>  <code>dataclass</code>","text":"<p>Class for Lowpass Filter Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass LowpassFilterInfo:\n    \"\"\"Class for Lowpass Filter Info\"\"\"\n\n    info: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; LowpassFilterInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`LowpassFilterInfo`][sm4file.sm4_object_types.LowpassFilterInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`LowpassFilterInfo`][sm4file.sm4_object_types.LowpassFilterInfo]\n        \"\"\"\n        _ = cursor.read_u32_le()\n        lowpass_filter_info = cursor.read_sm4_string()\n\n        return cls(lowpass_filter_info)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.LowpassFilterInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.LowpassFilterInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>LowpassFilterInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>LowpassFilterInfo</code> <p>The parsed <code>LowpassFilterInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; LowpassFilterInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`LowpassFilterInfo`][sm4file.sm4_object_types.LowpassFilterInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`LowpassFilterInfo`][sm4file.sm4_object_types.LowpassFilterInfo]\n    \"\"\"\n    _ = cursor.read_u32_le()\n    lowpass_filter_info = cursor.read_sm4_string()\n\n    return cls(lowpass_filter_info)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PageData","title":"<code>PageData</code>  <code>dataclass</code>","text":"<p>Class for the measured data points</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass PageData:\n    \"\"\"Class for the measured data points\"\"\"\n\n    data: NDArray[np.float32]\n\n    @classmethod\n    def from_buffer(\n        cls, cursor: Cursor, size: int, z_scale: float, z_offset: float\n    ) -&gt; PageData:\n        \"\"\"Read the buffer's bytes into a\n        [`PageData`][sm4file.sm4_object_types.PageData]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n            size: Number of bytes to read\n            z_scale: Scaling factor of data\n            z_offset: Offset of data\n\n        Returns:\n            The parsed [`PageData`][sm4file.sm4_object_types.PageData]\n        \"\"\"\n        # cursor.set_position(offset)\n\n        raw_data = np.frombuffer(cursor.read(size), dtype=np.int32)\n        data: NDArray[np.float32] = raw_data * z_scale + z_offset\n        return cls(data)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PageData-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PageData.from_buffer","title":"<code>from_buffer(cursor, size, z_scale, z_offset)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>PageData</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <code>size</code> <code>int</code> <p>Number of bytes to read</p> required <code>z_scale</code> <code>float</code> <p>Scaling factor of data</p> required <code>z_offset</code> <code>float</code> <p>Offset of data</p> required <p>Returns:</p> Type Description <code>PageData</code> <p>The parsed <code>PageData</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls, cursor: Cursor, size: int, z_scale: float, z_offset: float\n) -&gt; PageData:\n    \"\"\"Read the buffer's bytes into a\n    [`PageData`][sm4file.sm4_object_types.PageData]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        size: Number of bytes to read\n        z_scale: Scaling factor of data\n        z_offset: Offset of data\n\n    Returns:\n        The parsed [`PageData`][sm4file.sm4_object_types.PageData]\n    \"\"\"\n    # cursor.set_position(offset)\n\n    raw_data = np.frombuffer(cursor.read(size), dtype=np.int32)\n    data: NDArray[np.float32] = raw_data * z_scale + z_offset\n    return cls(data)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PiControllerInfo","title":"<code>PiControllerInfo</code>  <code>dataclass</code>","text":"<p>Class for PI Controller Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass PiControllerInfo:\n    \"\"\"Class for PI Controller Info\"\"\"\n\n    setpoint: float\n    proportional_gain: float\n    integral_gain: float\n    lower_bound: float\n    upper_bound: float\n    feedback_unit: str\n    setpoint_unit: str\n    proportional_gain_unit: str\n    integral_gain_unit: str\n    output_unit: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; PiControllerInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`PiControllerInfo`][sm4file.sm4_object_types.PiControllerInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`PiControllerInfo`][sm4file.sm4_object_types.PiControllerInfo]\n        \"\"\"\n        setpoint = cursor.read_f64_le()\n        proportional_gain = cursor.read_f64_le()\n        integral_gain = cursor.read_f64_le()\n        lower_bound = cursor.read_f64_le()\n        upper_bound = cursor.read_f64_le()\n        _ = cursor.read_u32_le()\n        feedback_unit = cursor.read_sm4_string()\n        setpoint_unit = cursor.read_sm4_string()\n        proportional_gain_unit = cursor.read_sm4_string()\n        integral_gain_unit = cursor.read_sm4_string()\n        output_unit = cursor.read_sm4_string()\n\n        return cls(\n            setpoint,\n            proportional_gain,\n            integral_gain,\n            lower_bound,\n            upper_bound,\n            feedback_unit,\n            setpoint_unit,\n            proportional_gain_unit,\n            integral_gain_unit,\n            output_unit,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PiControllerInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PiControllerInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>PiControllerInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>PiControllerInfo</code> <p>The parsed <code>PiControllerInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; PiControllerInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`PiControllerInfo`][sm4file.sm4_object_types.PiControllerInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`PiControllerInfo`][sm4file.sm4_object_types.PiControllerInfo]\n    \"\"\"\n    setpoint = cursor.read_f64_le()\n    proportional_gain = cursor.read_f64_le()\n    integral_gain = cursor.read_f64_le()\n    lower_bound = cursor.read_f64_le()\n    upper_bound = cursor.read_f64_le()\n    _ = cursor.read_u32_le()\n    feedback_unit = cursor.read_sm4_string()\n    setpoint_unit = cursor.read_sm4_string()\n    proportional_gain_unit = cursor.read_sm4_string()\n    integral_gain_unit = cursor.read_sm4_string()\n    output_unit = cursor.read_sm4_string()\n\n    return cls(\n        setpoint,\n        proportional_gain,\n        integral_gain,\n        lower_bound,\n        upper_bound,\n        feedback_unit,\n        setpoint_unit,\n        proportional_gain_unit,\n        integral_gain_unit,\n        output_unit,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PiezoSensitivity","title":"<code>PiezoSensitivity</code>  <code>dataclass</code>","text":"<p>Class for Piezo Sensitivity</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass PiezoSensitivity:\n    \"\"\"Class for Piezo Sensitivity\"\"\"\n\n    tube_x: float\n    tube_y: float\n    tube_z: float\n    tube_z_offset: float\n    scan_x: float\n    scan_y: float\n    scan_z: float\n    actuator: float\n    tube_x_unit: str\n    tube_y_unit: str\n    tube_z_unit: str\n    tube_z_unit_offset: str\n    scan_x_unit: str\n    scan_y_unit: str\n    scan_z_unit: str\n    actuator_unit: str\n    tube_calibration: str\n    scan_calibration: str\n    actuator_calibration: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; PiezoSensitivity:\n        \"\"\"Read the buffer's bytes into a\n        [`PiezoSensitivity`][sm4file.sm4_object_types.PiezoSensitivity]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`PiezoSensitivity`][sm4file.sm4_object_types.PiezoSensitivity]\n        \"\"\"\n        tube_x = cursor.read_f64_le()\n        tube_y = cursor.read_f64_le()\n        tube_z = cursor.read_f64_le()\n        tube_z_offset = cursor.read_f64_le()\n        scan_x = cursor.read_f64_le()\n        scan_y = cursor.read_f64_le()\n        scan_z = cursor.read_f64_le()\n        actuator = cursor.read_f64_le()\n\n        _ = cursor.read_u32_le()\n\n        tube_x_unit = cursor.read_sm4_string()\n        tube_y_unit = cursor.read_sm4_string()\n        tube_z_unit = cursor.read_sm4_string()\n        tube_z_unit_offset = cursor.read_sm4_string()\n        scan_x_unit = cursor.read_sm4_string()\n        scan_y_unit = cursor.read_sm4_string()\n        scan_z_unit = cursor.read_sm4_string()\n        actuator_unit = cursor.read_sm4_string()\n        tube_calibration = cursor.read_sm4_string()\n        scan_calibration = cursor.read_sm4_string()\n        actuator_calibration = cursor.read_sm4_string()\n\n        return cls(\n            tube_x,\n            tube_y,\n            tube_z,\n            tube_z_offset,\n            scan_x,\n            scan_y,\n            scan_z,\n            actuator,\n            tube_x_unit,\n            tube_y_unit,\n            tube_z_unit,\n            tube_z_unit_offset,\n            scan_x_unit,\n            scan_y_unit,\n            scan_z_unit,\n            actuator_unit,\n            tube_calibration,\n            scan_calibration,\n            actuator_calibration,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PiezoSensitivity-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PiezoSensitivity.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>PiezoSensitivity</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>PiezoSensitivity</code> <p>The parsed <code>PiezoSensitivity</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; PiezoSensitivity:\n    \"\"\"Read the buffer's bytes into a\n    [`PiezoSensitivity`][sm4file.sm4_object_types.PiezoSensitivity]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`PiezoSensitivity`][sm4file.sm4_object_types.PiezoSensitivity]\n    \"\"\"\n    tube_x = cursor.read_f64_le()\n    tube_y = cursor.read_f64_le()\n    tube_z = cursor.read_f64_le()\n    tube_z_offset = cursor.read_f64_le()\n    scan_x = cursor.read_f64_le()\n    scan_y = cursor.read_f64_le()\n    scan_z = cursor.read_f64_le()\n    actuator = cursor.read_f64_le()\n\n    _ = cursor.read_u32_le()\n\n    tube_x_unit = cursor.read_sm4_string()\n    tube_y_unit = cursor.read_sm4_string()\n    tube_z_unit = cursor.read_sm4_string()\n    tube_z_unit_offset = cursor.read_sm4_string()\n    scan_x_unit = cursor.read_sm4_string()\n    scan_y_unit = cursor.read_sm4_string()\n    scan_z_unit = cursor.read_sm4_string()\n    actuator_unit = cursor.read_sm4_string()\n    tube_calibration = cursor.read_sm4_string()\n    scan_calibration = cursor.read_sm4_string()\n    actuator_calibration = cursor.read_sm4_string()\n\n    return cls(\n        tube_x,\n        tube_y,\n        tube_z,\n        tube_z_offset,\n        scan_x,\n        scan_y,\n        scan_z,\n        actuator,\n        tube_x_unit,\n        tube_y_unit,\n        tube_z_unit,\n        tube_z_unit_offset,\n        scan_x_unit,\n        scan_y_unit,\n        scan_z_unit,\n        actuator_unit,\n        tube_calibration,\n        scan_calibration,\n        actuator_calibration,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PllInfo","title":"<code>PllInfo</code>  <code>dataclass</code>","text":"<p>Class for PLL Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass PllInfo:\n    \"\"\"Class for PLL Info\"\"\"\n\n    amplitude_control: int\n    drive_amplitude: float\n    drive_ref_frequency: float\n    lockin_freq_offset: float\n    lockin_harmonic_factor: float\n    lockin_phase_offset: float\n    pi_gain: float\n    pi_int_cutoff_frequency: float\n    pi_lower_bound: float\n    pi_upper_bound: float\n    diss_pi_gain: float\n    diss_pi_int_cutoff_frequency: float\n    diss_pi_lower_bound: float\n    diss_pi_upper_bound: float\n    lockin_filter_cutoff_frequency: str\n    drive_amplitude_unit: str\n    drive_ref_frequency_unit: str\n    lockin_freq_offset_unit: str\n    lockin_harmonic_factor_unit: str\n    lockin_phase_offset_unit: str\n    pi_gain_unit: str\n    pi_int_cutoff_frequency_unit: str\n    pi_lower_bound_unit: str\n    pi_upper_bound_unit: str\n    diss_pi_gain_unit: str\n    diss_pi_int_cutoff_frequency_unit: str\n    diss_pi_lower_bound_unit: str\n    diss_pi_upper_bound_unit: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; PllInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`PllInfo`][sm4file.sm4_object_types.PllInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`PllInfo`][sm4file.sm4_object_types.PllInfo]\n        \"\"\"\n        amplitude_control = cursor.read_u32_le()\n        drive_amplitude = cursor.read_f64_le()\n        drive_ref_frequency = cursor.read_f64_le()\n        lockin_freq_offset = cursor.read_f64_le()\n        lockin_harmonic_factor = cursor.read_f64_le()\n        lockin_phase_offset = cursor.read_f64_le()\n        pi_gain = cursor.read_f64_le()\n        pi_int_cutoff_frequency = cursor.read_f64_le()\n        pi_lower_bound = cursor.read_f64_le()\n        pi_upper_bound = cursor.read_f64_le()\n        diss_pi_gain = cursor.read_f64_le()\n        diss_pi_int_cutoff_frequency = cursor.read_f64_le()\n        diss_pi_lower_bound = cursor.read_f64_le()\n        diss_pi_upper_bound = cursor.read_f64_le()\n\n        lockin_filter_cutoff_frequency = cursor.read_sm4_string()\n\n        drive_amplitude_unit = cursor.read_sm4_string()\n        drive_ref_frequency_unit = cursor.read_sm4_string()\n        lockin_freq_offset_unit = cursor.read_sm4_string()\n        lockin_harmonic_factor_unit = cursor.read_sm4_string()\n        lockin_phase_offset_unit = cursor.read_sm4_string()\n        pi_gain_unit = cursor.read_sm4_string()\n        pi_int_cutoff_frequency_unit = cursor.read_sm4_string()\n        pi_lower_bound_unit = cursor.read_sm4_string()\n        pi_upper_bound_unit = cursor.read_sm4_string()\n        diss_pi_gain_unit = cursor.read_sm4_string()\n        diss_pi_int_cutoff_frequency_unit = cursor.read_sm4_string()\n        diss_pi_lower_bound_unit = cursor.read_sm4_string()\n        diss_pi_upper_bound_unit = cursor.read_sm4_string()\n\n        return cls(\n            amplitude_control,\n            drive_amplitude,\n            drive_ref_frequency,\n            lockin_freq_offset,\n            lockin_harmonic_factor,\n            lockin_phase_offset,\n            pi_gain,\n            pi_int_cutoff_frequency,\n            pi_lower_bound,\n            pi_upper_bound,\n            diss_pi_gain,\n            diss_pi_int_cutoff_frequency,\n            diss_pi_lower_bound,\n            diss_pi_upper_bound,\n            lockin_filter_cutoff_frequency,\n            drive_amplitude_unit,\n            drive_ref_frequency_unit,\n            lockin_freq_offset_unit,\n            lockin_harmonic_factor_unit,\n            lockin_phase_offset_unit,\n            pi_gain_unit,\n            pi_int_cutoff_frequency_unit,\n            pi_lower_bound_unit,\n            pi_upper_bound_unit,\n            diss_pi_gain_unit,\n            diss_pi_int_cutoff_frequency_unit,\n            diss_pi_lower_bound_unit,\n            diss_pi_upper_bound_unit,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PllInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PllInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>PllInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>PllInfo</code> <p>The parsed <code>PllInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; PllInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`PllInfo`][sm4file.sm4_object_types.PllInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`PllInfo`][sm4file.sm4_object_types.PllInfo]\n    \"\"\"\n    amplitude_control = cursor.read_u32_le()\n    drive_amplitude = cursor.read_f64_le()\n    drive_ref_frequency = cursor.read_f64_le()\n    lockin_freq_offset = cursor.read_f64_le()\n    lockin_harmonic_factor = cursor.read_f64_le()\n    lockin_phase_offset = cursor.read_f64_le()\n    pi_gain = cursor.read_f64_le()\n    pi_int_cutoff_frequency = cursor.read_f64_le()\n    pi_lower_bound = cursor.read_f64_le()\n    pi_upper_bound = cursor.read_f64_le()\n    diss_pi_gain = cursor.read_f64_le()\n    diss_pi_int_cutoff_frequency = cursor.read_f64_le()\n    diss_pi_lower_bound = cursor.read_f64_le()\n    diss_pi_upper_bound = cursor.read_f64_le()\n\n    lockin_filter_cutoff_frequency = cursor.read_sm4_string()\n\n    drive_amplitude_unit = cursor.read_sm4_string()\n    drive_ref_frequency_unit = cursor.read_sm4_string()\n    lockin_freq_offset_unit = cursor.read_sm4_string()\n    lockin_harmonic_factor_unit = cursor.read_sm4_string()\n    lockin_phase_offset_unit = cursor.read_sm4_string()\n    pi_gain_unit = cursor.read_sm4_string()\n    pi_int_cutoff_frequency_unit = cursor.read_sm4_string()\n    pi_lower_bound_unit = cursor.read_sm4_string()\n    pi_upper_bound_unit = cursor.read_sm4_string()\n    diss_pi_gain_unit = cursor.read_sm4_string()\n    diss_pi_int_cutoff_frequency_unit = cursor.read_sm4_string()\n    diss_pi_lower_bound_unit = cursor.read_sm4_string()\n    diss_pi_upper_bound_unit = cursor.read_sm4_string()\n\n    return cls(\n        amplitude_control,\n        drive_amplitude,\n        drive_ref_frequency,\n        lockin_freq_offset,\n        lockin_harmonic_factor,\n        lockin_phase_offset,\n        pi_gain,\n        pi_int_cutoff_frequency,\n        pi_lower_bound,\n        pi_upper_bound,\n        diss_pi_gain,\n        diss_pi_int_cutoff_frequency,\n        diss_pi_lower_bound,\n        diss_pi_upper_bound,\n        lockin_filter_cutoff_frequency,\n        drive_amplitude_unit,\n        drive_ref_frequency_unit,\n        lockin_freq_offset_unit,\n        lockin_harmonic_factor_unit,\n        lockin_phase_offset_unit,\n        pi_gain_unit,\n        pi_int_cutoff_frequency_unit,\n        pi_lower_bound_unit,\n        pi_upper_bound_unit,\n        diss_pi_gain_unit,\n        diss_pi_int_cutoff_frequency_unit,\n        diss_pi_lower_bound_unit,\n        diss_pi_upper_bound_unit,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.Prm","title":"<code>Prm</code>  <code>dataclass</code>","text":"<p>Class for PRM (Parameter) Data</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass Prm:\n    \"\"\"Class for PRM (Parameter) Data\"\"\"\n\n    prm_data: str\n\n    @classmethod\n    def from_buffer(\n        cls,\n        cursor: Cursor,\n        prm_compression_flag: int,\n        prm_data_size: int,\n        prm_compression_size: int,\n    ) -&gt; Prm:\n        \"\"\"Read the buffer's bytes into a\n        [`Prm`][sm4file.sm4_object_types.Prm]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n            prm_compression_flag: Indicates if PRM is compressed\n            prm_data_size: Size of the PRM data in bytes\n            prm_compression_size: Size of the PRM data in bytes if compressed\n\n        Returns:\n            The parsed [`Prm`][sm4file.sm4_object_types.Prm]\n        \"\"\"\n        if prm_compression_flag == 0:\n            prm_data_raw = cursor.read(prm_data_size)\n        else:\n            prm_data_raw = zlib.decompress(\n                cursor.read(prm_compression_size),\n                wbits=0,\n                bufsize=prm_data_size,\n            )\n\n        prm_data = prm_data_raw.decode(\"CP437\")\n        return cls(prm_data)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.Prm-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.Prm.from_buffer","title":"<code>from_buffer(cursor, prm_compression_flag, prm_data_size, prm_compression_size)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>Prm</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <code>prm_compression_flag</code> <code>int</code> <p>Indicates if PRM is compressed</p> required <code>prm_data_size</code> <code>int</code> <p>Size of the PRM data in bytes</p> required <code>prm_compression_size</code> <code>int</code> <p>Size of the PRM data in bytes if compressed</p> required <p>Returns:</p> Type Description <code>Prm</code> <p>The parsed <code>Prm</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls,\n    cursor: Cursor,\n    prm_compression_flag: int,\n    prm_data_size: int,\n    prm_compression_size: int,\n) -&gt; Prm:\n    \"\"\"Read the buffer's bytes into a\n    [`Prm`][sm4file.sm4_object_types.Prm]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        prm_compression_flag: Indicates if PRM is compressed\n        prm_data_size: Size of the PRM data in bytes\n        prm_compression_size: Size of the PRM data in bytes if compressed\n\n    Returns:\n        The parsed [`Prm`][sm4file.sm4_object_types.Prm]\n    \"\"\"\n    if prm_compression_flag == 0:\n        prm_data_raw = cursor.read(prm_data_size)\n    else:\n        prm_data_raw = zlib.decompress(\n            cursor.read(prm_compression_size),\n            wbits=0,\n            bufsize=prm_data_size,\n        )\n\n    prm_data = prm_data_raw.decode(\"CP437\")\n    return cls(prm_data)\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PrmHeader","title":"<code>PrmHeader</code>  <code>dataclass</code>","text":"<p>Class for PRM (Parameter) Header</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass PrmHeader:\n    \"\"\"Class for PRM (Parameter) Header\"\"\"\n\n    prm_compression_flag: int\n    prm_data_size: int\n    prm_compression_size: int\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; PrmHeader:\n        \"\"\"Read the buffer's bytes into a\n        [`PrmHeader`][sm4file.sm4_object_types.PrmHeader]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`PrmHeader`][sm4file.sm4_object_types.PrmHeader]\n        \"\"\"\n        prm_compression_flag = cursor.read_u32_le()\n        prm_data_size = cursor.read_u32_le()\n        prm_compression_size = cursor.read_u32_le()\n\n        # read the actual PRM data\n\n        return cls(\n            prm_compression_flag,\n            prm_data_size,\n            prm_compression_size,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PrmHeader-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.PrmHeader.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>PrmHeader</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>PrmHeader</code> <p>The parsed <code>PrmHeader</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; PrmHeader:\n    \"\"\"Read the buffer's bytes into a\n    [`PrmHeader`][sm4file.sm4_object_types.PrmHeader]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`PrmHeader`][sm4file.sm4_object_types.PrmHeader]\n    \"\"\"\n    prm_compression_flag = cursor.read_u32_le()\n    prm_data_size = cursor.read_u32_le()\n    prm_compression_size = cursor.read_u32_le()\n\n    # read the actual PRM data\n\n    return cls(\n        prm_compression_flag,\n        prm_data_size,\n        prm_compression_size,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.RhkDriftOptionType","title":"<code>RhkDriftOptionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum of Drift Options</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>class RhkDriftOptionType(Enum):\n    \"\"\"Enum of Drift Options\"\"\"\n\n    RHK_DRIFT_DISABLED = 0\n    RHK_DRIFT_EACH_SPECTRA = 1\n    RHK_DRIFT_EACH_LOCATION = 2\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ScanProcessorInfo","title":"<code>ScanProcessorInfo</code>  <code>dataclass</code>","text":"<p>Class for Scan Processor Info</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass ScanProcessorInfo:\n    \"\"\"Class for Scan Processor Info\"\"\"\n\n    x_slope_compensation: float\n    y_slope_compensation: float\n    x_slope_compensation_unit: str\n    y_slope_compensation_unit: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; ScanProcessorInfo:\n        \"\"\"Read the buffer's bytes into a\n        [`ScanProcessorInfo`][sm4file.sm4_object_types.ScanProcessorInfo]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`ScanProcessorInfo`][sm4file.sm4_object_types.ScanProcessorInfo]\n        \"\"\"\n        x_slope_compensation = cursor.read_f64_le()\n        y_slope_compensation = cursor.read_f64_le()\n        _ = cursor.read_u32_le()\n        x_slope_compensation_unit = cursor.read_sm4_string()\n        y_slope_compensation_unit = cursor.read_sm4_string()\n\n        return cls(\n            x_slope_compensation,\n            y_slope_compensation,\n            x_slope_compensation_unit,\n            y_slope_compensation_unit,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ScanProcessorInfo-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.ScanProcessorInfo.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>ScanProcessorInfo</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>ScanProcessorInfo</code> <p>The parsed <code>ScanProcessorInfo</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; ScanProcessorInfo:\n    \"\"\"Read the buffer's bytes into a\n    [`ScanProcessorInfo`][sm4file.sm4_object_types.ScanProcessorInfo]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`ScanProcessorInfo`][sm4file.sm4_object_types.ScanProcessorInfo]\n    \"\"\"\n    x_slope_compensation = cursor.read_f64_le()\n    y_slope_compensation = cursor.read_f64_le()\n    _ = cursor.read_u32_le()\n    x_slope_compensation_unit = cursor.read_sm4_string()\n    y_slope_compensation_unit = cursor.read_sm4_string()\n\n    return cls(\n        x_slope_compensation,\n        y_slope_compensation,\n        x_slope_compensation_unit,\n        y_slope_compensation_unit,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.SpecDriftData","title":"<code>SpecDriftData</code>  <code>dataclass</code>","text":"<p>Class for Spec Drift Data</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass SpecDriftData:\n    \"\"\"Class for Spec Drift Data\"\"\"\n\n    specdrift_time: List[float]\n    specdrift_x_coord: List[float]\n    specdrift_y_coord: List[float]\n    specdrift_dx: List[float]\n    specdrift_dy: List[float]\n    specdrift_cumulative_x: List[float]\n    specdrift_cumulative_y: List[float]\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor, y_size: int) -&gt; SpecDriftData:\n        \"\"\"Read the buffer's bytes into a\n        [`SpecDriftData`][sm4file.sm4_object_types.SpecDriftData]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`SpecDriftData`][sm4file.sm4_object_types.SpecDriftData]\n        \"\"\"\n        specdrift_time: List[float] = []\n        specdrift_x_coord: List[float] = []\n        specdrift_y_coord: List[float] = []\n        specdrift_dx: List[float] = []\n        specdrift_dy: List[float] = []\n        specdrift_cumulative_x: List[float] = []\n        specdrift_cumulative_y: List[float] = []\n\n        for _ in range(y_size):\n            specdrift_time.append(cursor.read_f32_le())\n            specdrift_x_coord.append(cursor.read_f32_le())\n            specdrift_y_coord.append(cursor.read_f32_le())\n            specdrift_dx.append(cursor.read_f32_le())\n            specdrift_dy.append(cursor.read_f32_le())\n            specdrift_cumulative_x.append(cursor.read_f32_le())\n            specdrift_cumulative_y.append(cursor.read_f32_le())\n\n        return cls(\n            specdrift_time,\n            specdrift_x_coord,\n            specdrift_y_coord,\n            specdrift_dx,\n            specdrift_dy,\n            specdrift_cumulative_x,\n            specdrift_cumulative_y,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.SpecDriftData-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.SpecDriftData.from_buffer","title":"<code>from_buffer(cursor, y_size)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>SpecDriftData</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>SpecDriftData</code> <p>The parsed <code>SpecDriftData</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor, y_size: int) -&gt; SpecDriftData:\n    \"\"\"Read the buffer's bytes into a\n    [`SpecDriftData`][sm4file.sm4_object_types.SpecDriftData]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`SpecDriftData`][sm4file.sm4_object_types.SpecDriftData]\n    \"\"\"\n    specdrift_time: List[float] = []\n    specdrift_x_coord: List[float] = []\n    specdrift_y_coord: List[float] = []\n    specdrift_dx: List[float] = []\n    specdrift_dy: List[float] = []\n    specdrift_cumulative_x: List[float] = []\n    specdrift_cumulative_y: List[float] = []\n\n    for _ in range(y_size):\n        specdrift_time.append(cursor.read_f32_le())\n        specdrift_x_coord.append(cursor.read_f32_le())\n        specdrift_y_coord.append(cursor.read_f32_le())\n        specdrift_dx.append(cursor.read_f32_le())\n        specdrift_dy.append(cursor.read_f32_le())\n        specdrift_cumulative_x.append(cursor.read_f32_le())\n        specdrift_cumulative_y.append(cursor.read_f32_le())\n\n    return cls(\n        specdrift_time,\n        specdrift_x_coord,\n        specdrift_y_coord,\n        specdrift_dx,\n        specdrift_dy,\n        specdrift_cumulative_x,\n        specdrift_cumulative_y,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.SpecDriftHeader","title":"<code>SpecDriftHeader</code>  <code>dataclass</code>","text":"<p>Class for Spec Drift Header</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass SpecDriftHeader:\n    \"\"\"Class for Spec Drift Header\"\"\"\n\n    specdrift_filetime: int\n    specdrift_drift_option_type: int\n    specdrift_drift_option_type_name: str\n    specdrift_channel: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; SpecDriftHeader:\n        \"\"\"Read the buffer's bytes into a\n        [`SpecDriftHeader`][sm4file.sm4_object_types.SpecDriftHeader]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`SpecDriftHeader`][sm4file.sm4_object_types.SpecDriftHeader]\n        \"\"\"\n        # unix epoch\n        specdrift_filetime = cursor.read_u64_le()\n        specdrift_drift_option_type = cursor.read_u32_le()\n        if specdrift_drift_option_type == 0:\n            specdrift_drift_option_type_name = \"RHK_DRIFT_DISABLED\"\n        elif specdrift_drift_option_type == 1:\n            specdrift_drift_option_type_name = \"RHK_DRIFT_EACH_SPECTRA\"\n        elif specdrift_drift_option_type == 1:\n            specdrift_drift_option_type_name = \"RHK_DRIFT_EACH_LOCATION\"\n        else:\n            specdrift_drift_option_type_name = \"RHK_DRIFT_UNKNOWN\"\n\n        _ = cursor.read_u32_le()\n        specdrift_channel = cursor.read_sm4_string()\n\n        return cls(\n            specdrift_filetime,\n            specdrift_drift_option_type,\n            specdrift_drift_option_type_name,\n            specdrift_channel,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.SpecDriftHeader-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.SpecDriftHeader.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>SpecDriftHeader</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>SpecDriftHeader</code> <p>The parsed <code>SpecDriftHeader</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; SpecDriftHeader:\n    \"\"\"Read the buffer's bytes into a\n    [`SpecDriftHeader`][sm4file.sm4_object_types.SpecDriftHeader]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`SpecDriftHeader`][sm4file.sm4_object_types.SpecDriftHeader]\n    \"\"\"\n    # unix epoch\n    specdrift_filetime = cursor.read_u64_le()\n    specdrift_drift_option_type = cursor.read_u32_le()\n    if specdrift_drift_option_type == 0:\n        specdrift_drift_option_type_name = \"RHK_DRIFT_DISABLED\"\n    elif specdrift_drift_option_type == 1:\n        specdrift_drift_option_type_name = \"RHK_DRIFT_EACH_SPECTRA\"\n    elif specdrift_drift_option_type == 1:\n        specdrift_drift_option_type_name = \"RHK_DRIFT_EACH_LOCATION\"\n    else:\n        specdrift_drift_option_type_name = \"RHK_DRIFT_UNKNOWN\"\n\n    _ = cursor.read_u32_le()\n    specdrift_channel = cursor.read_sm4_string()\n\n    return cls(\n        specdrift_filetime,\n        specdrift_drift_option_type,\n        specdrift_drift_option_type_name,\n        specdrift_channel,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.StringData","title":"<code>StringData</code>  <code>dataclass</code>","text":"<p>Class for String Data</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass StringData:\n    \"\"\"Class for String Data\"\"\"\n\n    label: str\n    system_text: str\n    session_text: str\n    user_text: str\n    filename: str\n    date: str\n    time: str\n    x_units: str\n    y_units: str\n    z_units: str\n    x_label: str\n    y_label: str\n    status_channel_text: str\n    completed_line_count: str\n    oversampling_count: str\n    sliced_voltage: str\n    pll_pro_status: str\n    setpoint_unit: str\n    channel_list: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor, count: int) -&gt; StringData:\n        \"\"\"Read the buffer's bytes into a\n        [`StringData`][sm4file.sm4_object_types.StringData]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`StringData`][sm4file.sm4_object_types.StringData]\n        \"\"\"\n        strings = [cursor.read_sm4_string() for _ in range(count)]\n\n        label = strings[0]\n        system_text = strings[1]\n        session_text = strings[2]\n        user_text = strings[3]\n        filename = strings[4]\n        date = strings[5]\n        time = strings[6]\n        x_units = strings[7]\n        y_units = strings[8]\n        z_units = strings[9]\n        x_label = strings[10]\n        y_label = strings[11]\n        status_channel_text = strings[12]\n        completed_line_count = strings[13]\n        try:\n            oversampling_count = strings[14]\n            sliced_voltage = strings[15]\n            pll_pro_status = strings[16]\n            setpoint_unit = strings[17]\n            channel_list = strings[18]\n        except IndexError:\n            oversampling_count = \"\"\n            sliced_voltage = \"\"\n            pll_pro_status = \"\"\n            setpoint_unit = \"\"\n            channel_list = \"\"\n\n        return cls(\n            label,\n            system_text,\n            session_text,\n            user_text,\n            filename,\n            date,\n            time,\n            x_units,\n            y_units,\n            z_units,\n            x_label,\n            y_label,\n            status_channel_text,\n            completed_line_count,\n            oversampling_count,\n            sliced_voltage,\n            pll_pro_status,\n            setpoint_unit,\n            channel_list,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.StringData-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.StringData.from_buffer","title":"<code>from_buffer(cursor, count)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>StringData</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>StringData</code> <p>The parsed <code>StringData</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor, count: int) -&gt; StringData:\n    \"\"\"Read the buffer's bytes into a\n    [`StringData`][sm4file.sm4_object_types.StringData]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`StringData`][sm4file.sm4_object_types.StringData]\n    \"\"\"\n    strings = [cursor.read_sm4_string() for _ in range(count)]\n\n    label = strings[0]\n    system_text = strings[1]\n    session_text = strings[2]\n    user_text = strings[3]\n    filename = strings[4]\n    date = strings[5]\n    time = strings[6]\n    x_units = strings[7]\n    y_units = strings[8]\n    z_units = strings[9]\n    x_label = strings[10]\n    y_label = strings[11]\n    status_channel_text = strings[12]\n    completed_line_count = strings[13]\n    try:\n        oversampling_count = strings[14]\n        sliced_voltage = strings[15]\n        pll_pro_status = strings[16]\n        setpoint_unit = strings[17]\n        channel_list = strings[18]\n    except IndexError:\n        oversampling_count = \"\"\n        sliced_voltage = \"\"\n        pll_pro_status = \"\"\n        setpoint_unit = \"\"\n        channel_list = \"\"\n\n    return cls(\n        label,\n        system_text,\n        session_text,\n        user_text,\n        filename,\n        date,\n        time,\n        x_units,\n        y_units,\n        z_units,\n        x_label,\n        y_label,\n        status_channel_text,\n        completed_line_count,\n        oversampling_count,\n        sliced_voltage,\n        pll_pro_status,\n        setpoint_unit,\n        channel_list,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.TipTrackData","title":"<code>TipTrackData</code>  <code>dataclass</code>","text":"<p>Class for Tip Track Data</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass TipTrackData:\n    \"\"\"Class for Tip Track Data\"\"\"\n\n    tiptrack_cumulative_time: List[float]\n    tiptrack_time: List[float]\n    tiptrack_dx: List[float]\n    tiptrack_dy: List[float]\n\n    @classmethod\n    def from_buffer(\n        cls, cursor: Cursor, tiptrack_info_count: int\n    ) -&gt; TipTrackData:\n        \"\"\"Read the buffer's bytes into a\n        [`TipTrackData`][sm4file.sm4_object_types.TipTrackData]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n            tiptrack_info_count: Number of info parameters\n\n        Returns:\n            The parsed [`TipTrackData`][sm4file.sm4_object_types.TipTrackData]\n        \"\"\"\n        tiptrack_cumulative_time: List[float] = []\n        tiptrack_time: List[float] = []\n        tiptrack_dx: List[float] = []\n        tiptrack_dy: List[float] = []\n\n        for _ in range(tiptrack_info_count):\n            tiptrack_cumulative_time.append(cursor.read_f32_le())\n            tiptrack_time.append(cursor.read_f32_le())\n            tiptrack_dx.append(cursor.read_f32_le())\n            tiptrack_dy.append(cursor.read_f32_le())\n\n        return cls(\n            tiptrack_cumulative_time,\n            tiptrack_time,\n            tiptrack_dx,\n            tiptrack_dy,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.TipTrackData-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.TipTrackData.from_buffer","title":"<code>from_buffer(cursor, tiptrack_info_count)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>TipTrackData</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <code>tiptrack_info_count</code> <code>int</code> <p>Number of info parameters</p> required <p>Returns:</p> Type Description <code>TipTrackData</code> <p>The parsed <code>TipTrackData</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(\n    cls, cursor: Cursor, tiptrack_info_count: int\n) -&gt; TipTrackData:\n    \"\"\"Read the buffer's bytes into a\n    [`TipTrackData`][sm4file.sm4_object_types.TipTrackData]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n        tiptrack_info_count: Number of info parameters\n\n    Returns:\n        The parsed [`TipTrackData`][sm4file.sm4_object_types.TipTrackData]\n    \"\"\"\n    tiptrack_cumulative_time: List[float] = []\n    tiptrack_time: List[float] = []\n    tiptrack_dx: List[float] = []\n    tiptrack_dy: List[float] = []\n\n    for _ in range(tiptrack_info_count):\n        tiptrack_cumulative_time.append(cursor.read_f32_le())\n        tiptrack_time.append(cursor.read_f32_le())\n        tiptrack_dx.append(cursor.read_f32_le())\n        tiptrack_dy.append(cursor.read_f32_le())\n\n    return cls(\n        tiptrack_cumulative_time,\n        tiptrack_time,\n        tiptrack_dx,\n        tiptrack_dy,\n    )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.TipTrackHeader","title":"<code>TipTrackHeader</code>  <code>dataclass</code>","text":"<p>Class for Tip Track Header</p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@dataclass\nclass TipTrackHeader:\n    \"\"\"Class for Tip Track Header\"\"\"\n\n    tiptrack_filetime: int\n    tiptrack_feature_height: float\n    tiptrack_feature_width: float\n    tiptrack_time_constant: float\n    tiptrack_cycle_rate: float\n    tiptrack_phase_lag: float\n    tiptrack_tiptrack_info_count: int\n    tiptrack_channel: str\n\n    @classmethod\n    def from_buffer(cls, cursor: Cursor) -&gt; TipTrackHeader:\n        \"\"\"Read the buffer's bytes into a\n        [`TipTrackHeader`][sm4file.sm4_object_types.TipTrackHeader]\n\n        Args:\n            cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n        Returns:\n            The parsed [`TipTrackHeader`][sm4file.sm4_object_types.TipTrackHeader]\n        \"\"\"\n        # unix epoch\n        tiptrack_filetime = cursor.read_u64_le()\n        tiptrack_feature_height = cursor.read_f32_le()\n        tiptrack_feature_width = cursor.read_f32_le()\n        tiptrack_time_constant = cursor.read_f32_le()\n        tiptrack_cycle_rate = cursor.read_f32_le()\n        tiptrack_phase_lag = cursor.read_f32_le()\n        _ = cursor.read_u32_le()\n        tiptrack_tiptrack_info_count = cursor.read_u32_le()\n        tiptrack_channel = cursor.read_sm4_string()\n\n        return cls(\n            tiptrack_filetime,\n            tiptrack_feature_height,\n            tiptrack_feature_width,\n            tiptrack_time_constant,\n            tiptrack_cycle_rate,\n            tiptrack_phase_lag,\n            tiptrack_tiptrack_info_count,\n            tiptrack_channel,\n        )\n</code></pre>"},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.TipTrackHeader-functions","title":"Functions","text":""},{"location":"api-dev/sm4_object_types/#sm4file.sm4_object_types.TipTrackHeader.from_buffer","title":"<code>from_buffer(cursor)</code>  <code>classmethod</code>","text":"<p>Read the buffer's bytes into a <code>TipTrackHeader</code></p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p><code>Cursor</code> holding the buffer</p> required <p>Returns:</p> Type Description <code>TipTrackHeader</code> <p>The parsed <code>TipTrackHeader</code></p> Source code in <code>sm4file/sm4_object_types.py</code> <pre><code>@classmethod\ndef from_buffer(cls, cursor: Cursor) -&gt; TipTrackHeader:\n    \"\"\"Read the buffer's bytes into a\n    [`TipTrackHeader`][sm4file.sm4_object_types.TipTrackHeader]\n\n    Args:\n        cursor: [`Cursor`][sm4file.cursor.Cursor] holding the buffer\n\n    Returns:\n        The parsed [`TipTrackHeader`][sm4file.sm4_object_types.TipTrackHeader]\n    \"\"\"\n    # unix epoch\n    tiptrack_filetime = cursor.read_u64_le()\n    tiptrack_feature_height = cursor.read_f32_le()\n    tiptrack_feature_width = cursor.read_f32_le()\n    tiptrack_time_constant = cursor.read_f32_le()\n    tiptrack_cycle_rate = cursor.read_f32_le()\n    tiptrack_phase_lag = cursor.read_f32_le()\n    _ = cursor.read_u32_le()\n    tiptrack_tiptrack_info_count = cursor.read_u32_le()\n    tiptrack_channel = cursor.read_sm4_string()\n\n    return cls(\n        tiptrack_filetime,\n        tiptrack_feature_height,\n        tiptrack_feature_width,\n        tiptrack_time_constant,\n        tiptrack_cycle_rate,\n        tiptrack_phase_lag,\n        tiptrack_tiptrack_info_count,\n        tiptrack_channel,\n    )\n</code></pre>"}]}